// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.checkKnown
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects
import kotlin.Unit as KUnit

/**
 * The Price resource represents a price that can be billed on a subscription, resulting in a charge
 * on an invoice in the form of an invoice line item. Prices take a quantity and determine an amount
 * to bill.
 *
 * Orb supports a few different pricing models out of the box. Each of these models is serialized
 * differently in a given Price object. The model_type field determines the key for the
 * configuration object that is present.
 *
 * For more on the types of prices, see
 * [the core concepts documentation](/core-concepts#plan-and-price)
 */
@JsonDeserialize(using = Price.Deserializer::class)
@JsonSerialize(using = Price.Serializer::class)
class Price
private constructor(
    private val unit: Unit? = null,
    private val tiered: Tiered? = null,
    private val bulk: Bulk? = null,
    private val bulkWithFilters: BulkWithFilters? = null,
    private val package_: Package? = null,
    private val matrix: Matrix? = null,
    private val thresholdTotalAmount: ThresholdTotalAmount? = null,
    private val tieredPackage: TieredPackage? = null,
    private val tieredWithMinimum: TieredWithMinimum? = null,
    private val groupedTiered: GroupedTiered? = null,
    private val tieredPackageWithMinimum: TieredPackageWithMinimum? = null,
    private val packageWithAllocation: PackageWithAllocation? = null,
    private val unitWithPercent: UnitWithPercent? = null,
    private val matrixWithAllocation: MatrixWithAllocation? = null,
    private val tieredWithProration: TieredWithProration? = null,
    private val unitWithProration: UnitWithProration? = null,
    private val groupedAllocation: GroupedAllocation? = null,
    private val bulkWithProration: BulkWithProration? = null,
    private val groupedWithProratedMinimum: GroupedWithProratedMinimum? = null,
    private val groupedWithMeteredMinimum: GroupedWithMeteredMinimum? = null,
    private val groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds? = null,
    private val matrixWithDisplayName: MatrixWithDisplayName? = null,
    private val groupedTieredPackage: GroupedTieredPackage? = null,
    private val maxGroupTieredPackage: MaxGroupTieredPackage? = null,
    private val scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing? = null,
    private val scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing? = null,
    private val cumulativeGroupedBulk: CumulativeGroupedBulk? = null,
    private val minimum: Minimum? = null,
    private val percent: Percent? = null,
    private val eventOutput: EventOutput? = null,
    private val _json: JsonValue? = null,
) {

    fun unit(): Unit? = unit

    fun tiered(): Tiered? = tiered

    fun bulk(): Bulk? = bulk

    fun bulkWithFilters(): BulkWithFilters? = bulkWithFilters

    fun package_(): Package? = package_

    fun matrix(): Matrix? = matrix

    fun thresholdTotalAmount(): ThresholdTotalAmount? = thresholdTotalAmount

    fun tieredPackage(): TieredPackage? = tieredPackage

    fun tieredWithMinimum(): TieredWithMinimum? = tieredWithMinimum

    fun groupedTiered(): GroupedTiered? = groupedTiered

    fun tieredPackageWithMinimum(): TieredPackageWithMinimum? = tieredPackageWithMinimum

    fun packageWithAllocation(): PackageWithAllocation? = packageWithAllocation

    fun unitWithPercent(): UnitWithPercent? = unitWithPercent

    fun matrixWithAllocation(): MatrixWithAllocation? = matrixWithAllocation

    fun tieredWithProration(): TieredWithProration? = tieredWithProration

    fun unitWithProration(): UnitWithProration? = unitWithProration

    fun groupedAllocation(): GroupedAllocation? = groupedAllocation

    fun bulkWithProration(): BulkWithProration? = bulkWithProration

    fun groupedWithProratedMinimum(): GroupedWithProratedMinimum? = groupedWithProratedMinimum

    fun groupedWithMeteredMinimum(): GroupedWithMeteredMinimum? = groupedWithMeteredMinimum

    fun groupedWithMinMaxThresholds(): GroupedWithMinMaxThresholds? = groupedWithMinMaxThresholds

    fun matrixWithDisplayName(): MatrixWithDisplayName? = matrixWithDisplayName

    fun groupedTieredPackage(): GroupedTieredPackage? = groupedTieredPackage

    fun maxGroupTieredPackage(): MaxGroupTieredPackage? = maxGroupTieredPackage

    fun scalableMatrixWithUnitPricing(): ScalableMatrixWithUnitPricing? =
        scalableMatrixWithUnitPricing

    fun scalableMatrixWithTieredPricing(): ScalableMatrixWithTieredPricing? =
        scalableMatrixWithTieredPricing

    fun cumulativeGroupedBulk(): CumulativeGroupedBulk? = cumulativeGroupedBulk

    fun minimum(): Minimum? = minimum

    fun percent(): Percent? = percent

    fun eventOutput(): EventOutput? = eventOutput

    fun isUnit(): Boolean = unit != null

    fun isTiered(): Boolean = tiered != null

    fun isBulk(): Boolean = bulk != null

    fun isBulkWithFilters(): Boolean = bulkWithFilters != null

    fun isPackage(): Boolean = package_ != null

    fun isMatrix(): Boolean = matrix != null

    fun isThresholdTotalAmount(): Boolean = thresholdTotalAmount != null

    fun isTieredPackage(): Boolean = tieredPackage != null

    fun isTieredWithMinimum(): Boolean = tieredWithMinimum != null

    fun isGroupedTiered(): Boolean = groupedTiered != null

    fun isTieredPackageWithMinimum(): Boolean = tieredPackageWithMinimum != null

    fun isPackageWithAllocation(): Boolean = packageWithAllocation != null

    fun isUnitWithPercent(): Boolean = unitWithPercent != null

    fun isMatrixWithAllocation(): Boolean = matrixWithAllocation != null

    fun isTieredWithProration(): Boolean = tieredWithProration != null

    fun isUnitWithProration(): Boolean = unitWithProration != null

    fun isGroupedAllocation(): Boolean = groupedAllocation != null

    fun isBulkWithProration(): Boolean = bulkWithProration != null

    fun isGroupedWithProratedMinimum(): Boolean = groupedWithProratedMinimum != null

    fun isGroupedWithMeteredMinimum(): Boolean = groupedWithMeteredMinimum != null

    fun isGroupedWithMinMaxThresholds(): Boolean = groupedWithMinMaxThresholds != null

    fun isMatrixWithDisplayName(): Boolean = matrixWithDisplayName != null

    fun isGroupedTieredPackage(): Boolean = groupedTieredPackage != null

    fun isMaxGroupTieredPackage(): Boolean = maxGroupTieredPackage != null

    fun isScalableMatrixWithUnitPricing(): Boolean = scalableMatrixWithUnitPricing != null

    fun isScalableMatrixWithTieredPricing(): Boolean = scalableMatrixWithTieredPricing != null

    fun isCumulativeGroupedBulk(): Boolean = cumulativeGroupedBulk != null

    fun isMinimum(): Boolean = minimum != null

    fun isPercent(): Boolean = percent != null

    fun isEventOutput(): Boolean = eventOutput != null

    fun asUnit(): Unit = unit.getOrThrow("unit")

    fun asTiered(): Tiered = tiered.getOrThrow("tiered")

    fun asBulk(): Bulk = bulk.getOrThrow("bulk")

    fun asBulkWithFilters(): BulkWithFilters = bulkWithFilters.getOrThrow("bulkWithFilters")

    fun asPackage(): Package = package_.getOrThrow("package_")

    fun asMatrix(): Matrix = matrix.getOrThrow("matrix")

    fun asThresholdTotalAmount(): ThresholdTotalAmount =
        thresholdTotalAmount.getOrThrow("thresholdTotalAmount")

    fun asTieredPackage(): TieredPackage = tieredPackage.getOrThrow("tieredPackage")

    fun asTieredWithMinimum(): TieredWithMinimum = tieredWithMinimum.getOrThrow("tieredWithMinimum")

    fun asGroupedTiered(): GroupedTiered = groupedTiered.getOrThrow("groupedTiered")

    fun asTieredPackageWithMinimum(): TieredPackageWithMinimum =
        tieredPackageWithMinimum.getOrThrow("tieredPackageWithMinimum")

    fun asPackageWithAllocation(): PackageWithAllocation =
        packageWithAllocation.getOrThrow("packageWithAllocation")

    fun asUnitWithPercent(): UnitWithPercent = unitWithPercent.getOrThrow("unitWithPercent")

    fun asMatrixWithAllocation(): MatrixWithAllocation =
        matrixWithAllocation.getOrThrow("matrixWithAllocation")

    fun asTieredWithProration(): TieredWithProration =
        tieredWithProration.getOrThrow("tieredWithProration")

    fun asUnitWithProration(): UnitWithProration = unitWithProration.getOrThrow("unitWithProration")

    fun asGroupedAllocation(): GroupedAllocation = groupedAllocation.getOrThrow("groupedAllocation")

    fun asBulkWithProration(): BulkWithProration = bulkWithProration.getOrThrow("bulkWithProration")

    fun asGroupedWithProratedMinimum(): GroupedWithProratedMinimum =
        groupedWithProratedMinimum.getOrThrow("groupedWithProratedMinimum")

    fun asGroupedWithMeteredMinimum(): GroupedWithMeteredMinimum =
        groupedWithMeteredMinimum.getOrThrow("groupedWithMeteredMinimum")

    fun asGroupedWithMinMaxThresholds(): GroupedWithMinMaxThresholds =
        groupedWithMinMaxThresholds.getOrThrow("groupedWithMinMaxThresholds")

    fun asMatrixWithDisplayName(): MatrixWithDisplayName =
        matrixWithDisplayName.getOrThrow("matrixWithDisplayName")

    fun asGroupedTieredPackage(): GroupedTieredPackage =
        groupedTieredPackage.getOrThrow("groupedTieredPackage")

    fun asMaxGroupTieredPackage(): MaxGroupTieredPackage =
        maxGroupTieredPackage.getOrThrow("maxGroupTieredPackage")

    fun asScalableMatrixWithUnitPricing(): ScalableMatrixWithUnitPricing =
        scalableMatrixWithUnitPricing.getOrThrow("scalableMatrixWithUnitPricing")

    fun asScalableMatrixWithTieredPricing(): ScalableMatrixWithTieredPricing =
        scalableMatrixWithTieredPricing.getOrThrow("scalableMatrixWithTieredPricing")

    fun asCumulativeGroupedBulk(): CumulativeGroupedBulk =
        cumulativeGroupedBulk.getOrThrow("cumulativeGroupedBulk")

    fun asMinimum(): Minimum = minimum.getOrThrow("minimum")

    fun asPercent(): Percent = percent.getOrThrow("percent")

    fun asEventOutput(): EventOutput = eventOutput.getOrThrow("eventOutput")

    fun _json(): JsonValue? = _json

    fun <T> accept(visitor: Visitor<T>): T =
        when {
            unit != null -> visitor.visitUnit(unit)
            tiered != null -> visitor.visitTiered(tiered)
            bulk != null -> visitor.visitBulk(bulk)
            bulkWithFilters != null -> visitor.visitBulkWithFilters(bulkWithFilters)
            package_ != null -> visitor.visitPackage(package_)
            matrix != null -> visitor.visitMatrix(matrix)
            thresholdTotalAmount != null -> visitor.visitThresholdTotalAmount(thresholdTotalAmount)
            tieredPackage != null -> visitor.visitTieredPackage(tieredPackage)
            tieredWithMinimum != null -> visitor.visitTieredWithMinimum(tieredWithMinimum)
            groupedTiered != null -> visitor.visitGroupedTiered(groupedTiered)
            tieredPackageWithMinimum != null ->
                visitor.visitTieredPackageWithMinimum(tieredPackageWithMinimum)
            packageWithAllocation != null ->
                visitor.visitPackageWithAllocation(packageWithAllocation)
            unitWithPercent != null -> visitor.visitUnitWithPercent(unitWithPercent)
            matrixWithAllocation != null -> visitor.visitMatrixWithAllocation(matrixWithAllocation)
            tieredWithProration != null -> visitor.visitTieredWithProration(tieredWithProration)
            unitWithProration != null -> visitor.visitUnitWithProration(unitWithProration)
            groupedAllocation != null -> visitor.visitGroupedAllocation(groupedAllocation)
            bulkWithProration != null -> visitor.visitBulkWithProration(bulkWithProration)
            groupedWithProratedMinimum != null ->
                visitor.visitGroupedWithProratedMinimum(groupedWithProratedMinimum)
            groupedWithMeteredMinimum != null ->
                visitor.visitGroupedWithMeteredMinimum(groupedWithMeteredMinimum)
            groupedWithMinMaxThresholds != null ->
                visitor.visitGroupedWithMinMaxThresholds(groupedWithMinMaxThresholds)
            matrixWithDisplayName != null ->
                visitor.visitMatrixWithDisplayName(matrixWithDisplayName)
            groupedTieredPackage != null -> visitor.visitGroupedTieredPackage(groupedTieredPackage)
            maxGroupTieredPackage != null ->
                visitor.visitMaxGroupTieredPackage(maxGroupTieredPackage)
            scalableMatrixWithUnitPricing != null ->
                visitor.visitScalableMatrixWithUnitPricing(scalableMatrixWithUnitPricing)
            scalableMatrixWithTieredPricing != null ->
                visitor.visitScalableMatrixWithTieredPricing(scalableMatrixWithTieredPricing)
            cumulativeGroupedBulk != null ->
                visitor.visitCumulativeGroupedBulk(cumulativeGroupedBulk)
            minimum != null -> visitor.visitMinimum(minimum)
            percent != null -> visitor.visitPercent(percent)
            eventOutput != null -> visitor.visitEventOutput(eventOutput)
            else -> visitor.unknown(_json)
        }

    private var validated: Boolean = false

    fun validate(): Price = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<KUnit> {
                override fun visitUnit(unit: Unit) {
                    unit.validate()
                }

                override fun visitTiered(tiered: Tiered) {
                    tiered.validate()
                }

                override fun visitBulk(bulk: Bulk) {
                    bulk.validate()
                }

                override fun visitBulkWithFilters(bulkWithFilters: BulkWithFilters) {
                    bulkWithFilters.validate()
                }

                override fun visitPackage(package_: Package) {
                    package_.validate()
                }

                override fun visitMatrix(matrix: Matrix) {
                    matrix.validate()
                }

                override fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) {
                    thresholdTotalAmount.validate()
                }

                override fun visitTieredPackage(tieredPackage: TieredPackage) {
                    tieredPackage.validate()
                }

                override fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) {
                    tieredWithMinimum.validate()
                }

                override fun visitGroupedTiered(groupedTiered: GroupedTiered) {
                    groupedTiered.validate()
                }

                override fun visitTieredPackageWithMinimum(
                    tieredPackageWithMinimum: TieredPackageWithMinimum
                ) {
                    tieredPackageWithMinimum.validate()
                }

                override fun visitPackageWithAllocation(
                    packageWithAllocation: PackageWithAllocation
                ) {
                    packageWithAllocation.validate()
                }

                override fun visitUnitWithPercent(unitWithPercent: UnitWithPercent) {
                    unitWithPercent.validate()
                }

                override fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) {
                    matrixWithAllocation.validate()
                }

                override fun visitTieredWithProration(tieredWithProration: TieredWithProration) {
                    tieredWithProration.validate()
                }

                override fun visitUnitWithProration(unitWithProration: UnitWithProration) {
                    unitWithProration.validate()
                }

                override fun visitGroupedAllocation(groupedAllocation: GroupedAllocation) {
                    groupedAllocation.validate()
                }

                override fun visitBulkWithProration(bulkWithProration: BulkWithProration) {
                    bulkWithProration.validate()
                }

                override fun visitGroupedWithProratedMinimum(
                    groupedWithProratedMinimum: GroupedWithProratedMinimum
                ) {
                    groupedWithProratedMinimum.validate()
                }

                override fun visitGroupedWithMeteredMinimum(
                    groupedWithMeteredMinimum: GroupedWithMeteredMinimum
                ) {
                    groupedWithMeteredMinimum.validate()
                }

                override fun visitGroupedWithMinMaxThresholds(
                    groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
                ) {
                    groupedWithMinMaxThresholds.validate()
                }

                override fun visitMatrixWithDisplayName(
                    matrixWithDisplayName: MatrixWithDisplayName
                ) {
                    matrixWithDisplayName.validate()
                }

                override fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) {
                    groupedTieredPackage.validate()
                }

                override fun visitMaxGroupTieredPackage(
                    maxGroupTieredPackage: MaxGroupTieredPackage
                ) {
                    maxGroupTieredPackage.validate()
                }

                override fun visitScalableMatrixWithUnitPricing(
                    scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
                ) {
                    scalableMatrixWithUnitPricing.validate()
                }

                override fun visitScalableMatrixWithTieredPricing(
                    scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
                ) {
                    scalableMatrixWithTieredPricing.validate()
                }

                override fun visitCumulativeGroupedBulk(
                    cumulativeGroupedBulk: CumulativeGroupedBulk
                ) {
                    cumulativeGroupedBulk.validate()
                }

                override fun visitMinimum(minimum: Minimum) {
                    minimum.validate()
                }

                override fun visitPercent(percent: Percent) {
                    percent.validate()
                }

                override fun visitEventOutput(eventOutput: EventOutput) {
                    eventOutput.validate()
                }
            }
        )
        validated = true
    }

    fun isValid(): Boolean =
        try {
            validate()
            true
        } catch (e: OrbInvalidDataException) {
            false
        }

    /**
     * Returns a score indicating how many valid values are contained in this object recursively.
     *
     * Used for best match union deserialization.
     */
    internal fun validity(): Int =
        accept(
            object : Visitor<Int> {
                override fun visitUnit(unit: Unit) = unit.validity()

                override fun visitTiered(tiered: Tiered) = tiered.validity()

                override fun visitBulk(bulk: Bulk) = bulk.validity()

                override fun visitBulkWithFilters(bulkWithFilters: BulkWithFilters) =
                    bulkWithFilters.validity()

                override fun visitPackage(package_: Package) = package_.validity()

                override fun visitMatrix(matrix: Matrix) = matrix.validity()

                override fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) =
                    thresholdTotalAmount.validity()

                override fun visitTieredPackage(tieredPackage: TieredPackage) =
                    tieredPackage.validity()

                override fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) =
                    tieredWithMinimum.validity()

                override fun visitGroupedTiered(groupedTiered: GroupedTiered) =
                    groupedTiered.validity()

                override fun visitTieredPackageWithMinimum(
                    tieredPackageWithMinimum: TieredPackageWithMinimum
                ) = tieredPackageWithMinimum.validity()

                override fun visitPackageWithAllocation(
                    packageWithAllocation: PackageWithAllocation
                ) = packageWithAllocation.validity()

                override fun visitUnitWithPercent(unitWithPercent: UnitWithPercent) =
                    unitWithPercent.validity()

                override fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) =
                    matrixWithAllocation.validity()

                override fun visitTieredWithProration(tieredWithProration: TieredWithProration) =
                    tieredWithProration.validity()

                override fun visitUnitWithProration(unitWithProration: UnitWithProration) =
                    unitWithProration.validity()

                override fun visitGroupedAllocation(groupedAllocation: GroupedAllocation) =
                    groupedAllocation.validity()

                override fun visitBulkWithProration(bulkWithProration: BulkWithProration) =
                    bulkWithProration.validity()

                override fun visitGroupedWithProratedMinimum(
                    groupedWithProratedMinimum: GroupedWithProratedMinimum
                ) = groupedWithProratedMinimum.validity()

                override fun visitGroupedWithMeteredMinimum(
                    groupedWithMeteredMinimum: GroupedWithMeteredMinimum
                ) = groupedWithMeteredMinimum.validity()

                override fun visitGroupedWithMinMaxThresholds(
                    groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
                ) = groupedWithMinMaxThresholds.validity()

                override fun visitMatrixWithDisplayName(
                    matrixWithDisplayName: MatrixWithDisplayName
                ) = matrixWithDisplayName.validity()

                override fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) =
                    groupedTieredPackage.validity()

                override fun visitMaxGroupTieredPackage(
                    maxGroupTieredPackage: MaxGroupTieredPackage
                ) = maxGroupTieredPackage.validity()

                override fun visitScalableMatrixWithUnitPricing(
                    scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
                ) = scalableMatrixWithUnitPricing.validity()

                override fun visitScalableMatrixWithTieredPricing(
                    scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
                ) = scalableMatrixWithTieredPricing.validity()

                override fun visitCumulativeGroupedBulk(
                    cumulativeGroupedBulk: CumulativeGroupedBulk
                ) = cumulativeGroupedBulk.validity()

                override fun visitMinimum(minimum: Minimum) = minimum.validity()

                override fun visitPercent(percent: Percent) = percent.validity()

                override fun visitEventOutput(eventOutput: EventOutput) = eventOutput.validity()

                override fun unknown(json: JsonValue?) = 0
            }
        )

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is Price &&
            unit == other.unit &&
            tiered == other.tiered &&
            bulk == other.bulk &&
            bulkWithFilters == other.bulkWithFilters &&
            package_ == other.package_ &&
            matrix == other.matrix &&
            thresholdTotalAmount == other.thresholdTotalAmount &&
            tieredPackage == other.tieredPackage &&
            tieredWithMinimum == other.tieredWithMinimum &&
            groupedTiered == other.groupedTiered &&
            tieredPackageWithMinimum == other.tieredPackageWithMinimum &&
            packageWithAllocation == other.packageWithAllocation &&
            unitWithPercent == other.unitWithPercent &&
            matrixWithAllocation == other.matrixWithAllocation &&
            tieredWithProration == other.tieredWithProration &&
            unitWithProration == other.unitWithProration &&
            groupedAllocation == other.groupedAllocation &&
            bulkWithProration == other.bulkWithProration &&
            groupedWithProratedMinimum == other.groupedWithProratedMinimum &&
            groupedWithMeteredMinimum == other.groupedWithMeteredMinimum &&
            groupedWithMinMaxThresholds == other.groupedWithMinMaxThresholds &&
            matrixWithDisplayName == other.matrixWithDisplayName &&
            groupedTieredPackage == other.groupedTieredPackage &&
            maxGroupTieredPackage == other.maxGroupTieredPackage &&
            scalableMatrixWithUnitPricing == other.scalableMatrixWithUnitPricing &&
            scalableMatrixWithTieredPricing == other.scalableMatrixWithTieredPricing &&
            cumulativeGroupedBulk == other.cumulativeGroupedBulk &&
            minimum == other.minimum &&
            percent == other.percent &&
            eventOutput == other.eventOutput
    }

    override fun hashCode(): Int =
        Objects.hash(
            unit,
            tiered,
            bulk,
            bulkWithFilters,
            package_,
            matrix,
            thresholdTotalAmount,
            tieredPackage,
            tieredWithMinimum,
            groupedTiered,
            tieredPackageWithMinimum,
            packageWithAllocation,
            unitWithPercent,
            matrixWithAllocation,
            tieredWithProration,
            unitWithProration,
            groupedAllocation,
            bulkWithProration,
            groupedWithProratedMinimum,
            groupedWithMeteredMinimum,
            groupedWithMinMaxThresholds,
            matrixWithDisplayName,
            groupedTieredPackage,
            maxGroupTieredPackage,
            scalableMatrixWithUnitPricing,
            scalableMatrixWithTieredPricing,
            cumulativeGroupedBulk,
            minimum,
            percent,
            eventOutput,
        )

    override fun toString(): String =
        when {
            unit != null -> "Price{unit=$unit}"
            tiered != null -> "Price{tiered=$tiered}"
            bulk != null -> "Price{bulk=$bulk}"
            bulkWithFilters != null -> "Price{bulkWithFilters=$bulkWithFilters}"
            package_ != null -> "Price{package_=$package_}"
            matrix != null -> "Price{matrix=$matrix}"
            thresholdTotalAmount != null -> "Price{thresholdTotalAmount=$thresholdTotalAmount}"
            tieredPackage != null -> "Price{tieredPackage=$tieredPackage}"
            tieredWithMinimum != null -> "Price{tieredWithMinimum=$tieredWithMinimum}"
            groupedTiered != null -> "Price{groupedTiered=$groupedTiered}"
            tieredPackageWithMinimum != null ->
                "Price{tieredPackageWithMinimum=$tieredPackageWithMinimum}"
            packageWithAllocation != null -> "Price{packageWithAllocation=$packageWithAllocation}"
            unitWithPercent != null -> "Price{unitWithPercent=$unitWithPercent}"
            matrixWithAllocation != null -> "Price{matrixWithAllocation=$matrixWithAllocation}"
            tieredWithProration != null -> "Price{tieredWithProration=$tieredWithProration}"
            unitWithProration != null -> "Price{unitWithProration=$unitWithProration}"
            groupedAllocation != null -> "Price{groupedAllocation=$groupedAllocation}"
            bulkWithProration != null -> "Price{bulkWithProration=$bulkWithProration}"
            groupedWithProratedMinimum != null ->
                "Price{groupedWithProratedMinimum=$groupedWithProratedMinimum}"
            groupedWithMeteredMinimum != null ->
                "Price{groupedWithMeteredMinimum=$groupedWithMeteredMinimum}"
            groupedWithMinMaxThresholds != null ->
                "Price{groupedWithMinMaxThresholds=$groupedWithMinMaxThresholds}"
            matrixWithDisplayName != null -> "Price{matrixWithDisplayName=$matrixWithDisplayName}"
            groupedTieredPackage != null -> "Price{groupedTieredPackage=$groupedTieredPackage}"
            maxGroupTieredPackage != null -> "Price{maxGroupTieredPackage=$maxGroupTieredPackage}"
            scalableMatrixWithUnitPricing != null ->
                "Price{scalableMatrixWithUnitPricing=$scalableMatrixWithUnitPricing}"
            scalableMatrixWithTieredPricing != null ->
                "Price{scalableMatrixWithTieredPricing=$scalableMatrixWithTieredPricing}"
            cumulativeGroupedBulk != null -> "Price{cumulativeGroupedBulk=$cumulativeGroupedBulk}"
            minimum != null -> "Price{minimum=$minimum}"
            percent != null -> "Price{percent=$percent}"
            eventOutput != null -> "Price{eventOutput=$eventOutput}"
            _json != null -> "Price{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid Price")
        }

    companion object {

        fun ofUnit(unit: Unit) = Price(unit = unit)

        fun ofTiered(tiered: Tiered) = Price(tiered = tiered)

        fun ofBulk(bulk: Bulk) = Price(bulk = bulk)

        fun ofBulkWithFilters(bulkWithFilters: BulkWithFilters) =
            Price(bulkWithFilters = bulkWithFilters)

        fun ofPackage(package_: Package) = Price(package_ = package_)

        fun ofMatrix(matrix: Matrix) = Price(matrix = matrix)

        fun ofThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) =
            Price(thresholdTotalAmount = thresholdTotalAmount)

        fun ofTieredPackage(tieredPackage: TieredPackage) = Price(tieredPackage = tieredPackage)

        fun ofTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) =
            Price(tieredWithMinimum = tieredWithMinimum)

        fun ofGroupedTiered(groupedTiered: GroupedTiered) = Price(groupedTiered = groupedTiered)

        fun ofTieredPackageWithMinimum(tieredPackageWithMinimum: TieredPackageWithMinimum) =
            Price(tieredPackageWithMinimum = tieredPackageWithMinimum)

        fun ofPackageWithAllocation(packageWithAllocation: PackageWithAllocation) =
            Price(packageWithAllocation = packageWithAllocation)

        fun ofUnitWithPercent(unitWithPercent: UnitWithPercent) =
            Price(unitWithPercent = unitWithPercent)

        fun ofMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) =
            Price(matrixWithAllocation = matrixWithAllocation)

        fun ofTieredWithProration(tieredWithProration: TieredWithProration) =
            Price(tieredWithProration = tieredWithProration)

        fun ofUnitWithProration(unitWithProration: UnitWithProration) =
            Price(unitWithProration = unitWithProration)

        fun ofGroupedAllocation(groupedAllocation: GroupedAllocation) =
            Price(groupedAllocation = groupedAllocation)

        fun ofBulkWithProration(bulkWithProration: BulkWithProration) =
            Price(bulkWithProration = bulkWithProration)

        fun ofGroupedWithProratedMinimum(groupedWithProratedMinimum: GroupedWithProratedMinimum) =
            Price(groupedWithProratedMinimum = groupedWithProratedMinimum)

        fun ofGroupedWithMeteredMinimum(groupedWithMeteredMinimum: GroupedWithMeteredMinimum) =
            Price(groupedWithMeteredMinimum = groupedWithMeteredMinimum)

        fun ofGroupedWithMinMaxThresholds(
            groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
        ) = Price(groupedWithMinMaxThresholds = groupedWithMinMaxThresholds)

        fun ofMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayName) =
            Price(matrixWithDisplayName = matrixWithDisplayName)

        fun ofGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) =
            Price(groupedTieredPackage = groupedTieredPackage)

        fun ofMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackage) =
            Price(maxGroupTieredPackage = maxGroupTieredPackage)

        fun ofScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
        ) = Price(scalableMatrixWithUnitPricing = scalableMatrixWithUnitPricing)

        fun ofScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
        ) = Price(scalableMatrixWithTieredPricing = scalableMatrixWithTieredPricing)

        fun ofCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulk) =
            Price(cumulativeGroupedBulk = cumulativeGroupedBulk)

        fun ofMinimum(minimum: Minimum) = Price(minimum = minimum)

        fun ofPercent(percent: Percent) = Price(percent = percent)

        fun ofEventOutput(eventOutput: EventOutput) = Price(eventOutput = eventOutput)
    }

    /** An interface that defines how to map each variant of [Price] to a value of type [T]. */
    interface Visitor<out T> {

        fun visitUnit(unit: Unit): T

        fun visitTiered(tiered: Tiered): T

        fun visitBulk(bulk: Bulk): T

        fun visitBulkWithFilters(bulkWithFilters: BulkWithFilters): T

        fun visitPackage(package_: Package): T

        fun visitMatrix(matrix: Matrix): T

        fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount): T

        fun visitTieredPackage(tieredPackage: TieredPackage): T

        fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum): T

        fun visitGroupedTiered(groupedTiered: GroupedTiered): T

        fun visitTieredPackageWithMinimum(tieredPackageWithMinimum: TieredPackageWithMinimum): T

        fun visitPackageWithAllocation(packageWithAllocation: PackageWithAllocation): T

        fun visitUnitWithPercent(unitWithPercent: UnitWithPercent): T

        fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation): T

        fun visitTieredWithProration(tieredWithProration: TieredWithProration): T

        fun visitUnitWithProration(unitWithProration: UnitWithProration): T

        fun visitGroupedAllocation(groupedAllocation: GroupedAllocation): T

        fun visitBulkWithProration(bulkWithProration: BulkWithProration): T

        fun visitGroupedWithProratedMinimum(
            groupedWithProratedMinimum: GroupedWithProratedMinimum
        ): T

        fun visitGroupedWithMeteredMinimum(groupedWithMeteredMinimum: GroupedWithMeteredMinimum): T

        fun visitGroupedWithMinMaxThresholds(
            groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
        ): T

        fun visitMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayName): T

        fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage): T

        fun visitMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackage): T

        fun visitScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
        ): T

        fun visitScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
        ): T

        fun visitCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulk): T

        fun visitMinimum(minimum: Minimum): T

        fun visitPercent(percent: Percent): T

        fun visitEventOutput(eventOutput: EventOutput): T

        /**
         * Maps an unknown variant of [Price] to a value of type [T].
         *
         * An instance of [Price] can contain an unknown variant if it was deserialized from data
         * that doesn't match any known variant. For example, if the SDK is on an older version than
         * the API, then the API may respond with new variants that the SDK is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown Price: $json")
        }
    }

    internal class Deserializer : BaseDeserializer<Price>(Price::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): Price {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject()?.get("model_type")?.asString()

            when (modelType) {
                "unit" -> {
                    return tryDeserialize(node, jacksonTypeRef<Unit>())?.let {
                        Price(unit = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered" -> {
                    return tryDeserialize(node, jacksonTypeRef<Tiered>())?.let {
                        Price(tiered = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk" -> {
                    return tryDeserialize(node, jacksonTypeRef<Bulk>())?.let {
                        Price(bulk = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk_with_filters" -> {
                    return tryDeserialize(node, jacksonTypeRef<BulkWithFilters>())?.let {
                        Price(bulkWithFilters = it, _json = json)
                    } ?: Price(_json = json)
                }
                "package" -> {
                    return tryDeserialize(node, jacksonTypeRef<Package>())?.let {
                        Price(package_ = it, _json = json)
                    } ?: Price(_json = json)
                }
                "matrix" -> {
                    return tryDeserialize(node, jacksonTypeRef<Matrix>())?.let {
                        Price(matrix = it, _json = json)
                    } ?: Price(_json = json)
                }
                "threshold_total_amount" -> {
                    return tryDeserialize(node, jacksonTypeRef<ThresholdTotalAmount>())?.let {
                        Price(thresholdTotalAmount = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredPackage>())?.let {
                        Price(tieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_with_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredWithMinimum>())?.let {
                        Price(tieredWithMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_tiered" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedTiered>())?.let {
                        Price(groupedTiered = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_package_with_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredPackageWithMinimum>())?.let {
                        Price(tieredPackageWithMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "package_with_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<PackageWithAllocation>())?.let {
                        Price(packageWithAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "unit_with_percent" -> {
                    return tryDeserialize(node, jacksonTypeRef<UnitWithPercent>())?.let {
                        Price(unitWithPercent = it, _json = json)
                    } ?: Price(_json = json)
                }
                "matrix_with_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<MatrixWithAllocation>())?.let {
                        Price(matrixWithAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredWithProration>())?.let {
                        Price(tieredWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "unit_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<UnitWithProration>())?.let {
                        Price(unitWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedAllocation>())?.let {
                        Price(groupedAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<BulkWithProration>())?.let {
                        Price(bulkWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_prorated_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithProratedMinimum>())?.let {
                        Price(groupedWithProratedMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_metered_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithMeteredMinimum>())?.let {
                        Price(groupedWithMeteredMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_min_max_thresholds" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithMinMaxThresholds>())
                        ?.let { Price(groupedWithMinMaxThresholds = it, _json = json) }
                        ?: Price(_json = json)
                }
                "matrix_with_display_name" -> {
                    return tryDeserialize(node, jacksonTypeRef<MatrixWithDisplayName>())?.let {
                        Price(matrixWithDisplayName = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedTieredPackage>())?.let {
                        Price(groupedTieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "max_group_tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<MaxGroupTieredPackage>())?.let {
                        Price(maxGroupTieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "scalable_matrix_with_unit_pricing" -> {
                    return tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithUnitPricing>())
                        ?.let { Price(scalableMatrixWithUnitPricing = it, _json = json) }
                        ?: Price(_json = json)
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    return tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithTieredPricing>())
                        ?.let { Price(scalableMatrixWithTieredPricing = it, _json = json) }
                        ?: Price(_json = json)
                }
                "cumulative_grouped_bulk" -> {
                    return tryDeserialize(node, jacksonTypeRef<CumulativeGroupedBulk>())?.let {
                        Price(cumulativeGroupedBulk = it, _json = json)
                    } ?: Price(_json = json)
                }
                "minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<Minimum>())?.let {
                        Price(minimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "percent" -> {
                    return tryDeserialize(node, jacksonTypeRef<Percent>())?.let {
                        Price(percent = it, _json = json)
                    } ?: Price(_json = json)
                }
                "event_output" -> {
                    return tryDeserialize(node, jacksonTypeRef<EventOutput>())?.let {
                        Price(eventOutput = it, _json = json)
                    } ?: Price(_json = json)
                }
            }

            return Price(_json = json)
        }
    }

    internal class Serializer : BaseSerializer<Price>(Price::class) {

        override fun serialize(
            value: Price,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unit != null -> generator.writeObject(value.unit)
                value.tiered != null -> generator.writeObject(value.tiered)
                value.bulk != null -> generator.writeObject(value.bulk)
                value.bulkWithFilters != null -> generator.writeObject(value.bulkWithFilters)
                value.package_ != null -> generator.writeObject(value.package_)
                value.matrix != null -> generator.writeObject(value.matrix)
                value.thresholdTotalAmount != null ->
                    generator.writeObject(value.thresholdTotalAmount)
                value.tieredPackage != null -> generator.writeObject(value.tieredPackage)
                value.tieredWithMinimum != null -> generator.writeObject(value.tieredWithMinimum)
                value.groupedTiered != null -> generator.writeObject(value.groupedTiered)
                value.tieredPackageWithMinimum != null ->
                    generator.writeObject(value.tieredPackageWithMinimum)
                value.packageWithAllocation != null ->
                    generator.writeObject(value.packageWithAllocation)
                value.unitWithPercent != null -> generator.writeObject(value.unitWithPercent)
                value.matrixWithAllocation != null ->
                    generator.writeObject(value.matrixWithAllocation)
                value.tieredWithProration != null ->
                    generator.writeObject(value.tieredWithProration)
                value.unitWithProration != null -> generator.writeObject(value.unitWithProration)
                value.groupedAllocation != null -> generator.writeObject(value.groupedAllocation)
                value.bulkWithProration != null -> generator.writeObject(value.bulkWithProration)
                value.groupedWithProratedMinimum != null ->
                    generator.writeObject(value.groupedWithProratedMinimum)
                value.groupedWithMeteredMinimum != null ->
                    generator.writeObject(value.groupedWithMeteredMinimum)
                value.groupedWithMinMaxThresholds != null ->
                    generator.writeObject(value.groupedWithMinMaxThresholds)
                value.matrixWithDisplayName != null ->
                    generator.writeObject(value.matrixWithDisplayName)
                value.groupedTieredPackage != null ->
                    generator.writeObject(value.groupedTieredPackage)
                value.maxGroupTieredPackage != null ->
                    generator.writeObject(value.maxGroupTieredPackage)
                value.scalableMatrixWithUnitPricing != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricing)
                value.scalableMatrixWithTieredPricing != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricing)
                value.cumulativeGroupedBulk != null ->
                    generator.writeObject(value.cumulativeGroupedBulk)
                value.minimum != null -> generator.writeObject(value.minimum)
                value.percent != null -> generator.writeObject(value.percent)
                value.eventOutput != null -> generator.writeObject(value.eventOutput)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid Price")
            }
        }
    }

    class Unit
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitConfig: JsonField<UnitConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_config")
            @ExcludeMissing
            unitConfig: JsonField<UnitConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("unit")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for unit pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitConfig].
         *
         * Unlike [unitConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfig> = unitConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Unit].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Unit]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitConfig: JsonField<UnitConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(unit: Unit) = apply {
                id = unit.id
                billableMetric = unit.billableMetric
                billingCycleConfiguration = unit.billingCycleConfiguration
                billingMode = unit.billingMode
                cadence = unit.cadence
                compositePriceFilters = unit.compositePriceFilters.map { it.toMutableList() }
                conversionRate = unit.conversionRate
                conversionRateConfig = unit.conversionRateConfig
                createdAt = unit.createdAt
                creditAllocation = unit.creditAllocation
                currency = unit.currency
                discount = unit.discount
                externalPriceId = unit.externalPriceId
                fixedPriceQuantity = unit.fixedPriceQuantity
                invoicingCycleConfiguration = unit.invoicingCycleConfiguration
                item = unit.item
                maximum = unit.maximum
                maximumAmount = unit.maximumAmount
                metadata = unit.metadata
                minimum = unit.minimum
                minimumAmount = unit.minimumAmount
                modelType = unit.modelType
                name = unit.name
                planPhaseOrder = unit.planPhaseOrder
                priceType = unit.priceType
                replacesPriceId = unit.replacesPriceId
                unitConfig = unit.unitConfig
                dimensionalPriceConfiguration = unit.dimensionalPriceConfiguration
                additionalProperties = unit.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("unit")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for unit pricing */
            fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

            /**
             * Sets [Builder.unitConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitConfig] with a well-typed [UnitConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                this.unitConfig = unitConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Unit].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Unit =
                Unit(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitConfig", unitConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Unit = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("unit")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (unitConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Unit &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                unitConfig == other.unitConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                unitConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Unit{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitConfig=$unitConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Tiered
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredConfig: JsonField<TieredConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_config")
            @ExcludeMissing
            tieredConfig: JsonField<TieredConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("tiered")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for tiered pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredConfig].
         *
         * Unlike [tieredConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfig> = tieredConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Tiered].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Tiered]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredConfig: JsonField<TieredConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(tiered: Tiered) = apply {
                id = tiered.id
                billableMetric = tiered.billableMetric
                billingCycleConfiguration = tiered.billingCycleConfiguration
                billingMode = tiered.billingMode
                cadence = tiered.cadence
                compositePriceFilters = tiered.compositePriceFilters.map { it.toMutableList() }
                conversionRate = tiered.conversionRate
                conversionRateConfig = tiered.conversionRateConfig
                createdAt = tiered.createdAt
                creditAllocation = tiered.creditAllocation
                currency = tiered.currency
                discount = tiered.discount
                externalPriceId = tiered.externalPriceId
                fixedPriceQuantity = tiered.fixedPriceQuantity
                invoicingCycleConfiguration = tiered.invoicingCycleConfiguration
                item = tiered.item
                maximum = tiered.maximum
                maximumAmount = tiered.maximumAmount
                metadata = tiered.metadata
                minimum = tiered.minimum
                minimumAmount = tiered.minimumAmount
                modelType = tiered.modelType
                name = tiered.name
                planPhaseOrder = tiered.planPhaseOrder
                priceType = tiered.priceType
                replacesPriceId = tiered.replacesPriceId
                tieredConfig = tiered.tieredConfig
                dimensionalPriceConfiguration = tiered.dimensionalPriceConfiguration
                additionalProperties = tiered.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("tiered")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for tiered pricing */
            fun tieredConfig(tieredConfig: TieredConfig) = tieredConfig(JsonField.of(tieredConfig))

            /**
             * Sets [Builder.tieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredConfig] with a well-typed [TieredConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                this.tieredConfig = tieredConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Tiered].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Tiered =
                Tiered(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredConfig", tieredConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Tiered = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("tiered")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (tieredConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Tiered &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                tieredConfig == other.tieredConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                tieredConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Tiered{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredConfig=$tieredConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Bulk
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val bulkConfig: JsonField<BulkConfig>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("bulk_config")
            @ExcludeMissing
            bulkConfig: JsonField<BulkConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            bulkConfig,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * Configuration for bulk pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("bulk")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [bulkConfig].
         *
         * Unlike [bulkConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfig> = bulkConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Bulk].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Bulk]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var bulkConfig: JsonField<BulkConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(bulk: Bulk) = apply {
                id = bulk.id
                billableMetric = bulk.billableMetric
                billingCycleConfiguration = bulk.billingCycleConfiguration
                billingMode = bulk.billingMode
                bulkConfig = bulk.bulkConfig
                cadence = bulk.cadence
                compositePriceFilters = bulk.compositePriceFilters.map { it.toMutableList() }
                conversionRate = bulk.conversionRate
                conversionRateConfig = bulk.conversionRateConfig
                createdAt = bulk.createdAt
                creditAllocation = bulk.creditAllocation
                currency = bulk.currency
                discount = bulk.discount
                externalPriceId = bulk.externalPriceId
                fixedPriceQuantity = bulk.fixedPriceQuantity
                invoicingCycleConfiguration = bulk.invoicingCycleConfiguration
                item = bulk.item
                maximum = bulk.maximum
                maximumAmount = bulk.maximumAmount
                metadata = bulk.metadata
                minimum = bulk.minimum
                minimumAmount = bulk.minimumAmount
                modelType = bulk.modelType
                name = bulk.name
                planPhaseOrder = bulk.planPhaseOrder
                priceType = bulk.priceType
                replacesPriceId = bulk.replacesPriceId
                dimensionalPriceConfiguration = bulk.dimensionalPriceConfiguration
                additionalProperties = bulk.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            /** Configuration for bulk pricing */
            fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

            /**
             * Sets [Builder.bulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkConfig] with a well-typed [BulkConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                this.bulkConfig = bulkConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("bulk")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Bulk].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Bulk =
                Bulk(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Bulk = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            bulkConfig().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (bulkConfig.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("bulk")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Bulk &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                bulkConfig == other.bulkConfig &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                bulkConfig,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Bulk{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, bulkConfig=$bulkConfig, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class BulkWithFilters
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val bulkWithFiltersConfig: JsonField<BulkWithFiltersConfig>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("bulk_with_filters_config")
            @ExcludeMissing
            bulkWithFiltersConfig: JsonField<BulkWithFiltersConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            bulkWithFiltersConfig,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * Configuration for bulk_with_filters pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkWithFiltersConfig(): BulkWithFiltersConfig =
            bulkWithFiltersConfig.getRequired("bulk_with_filters_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("bulk_with_filters")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [bulkWithFiltersConfig].
         *
         * Unlike [bulkWithFiltersConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("bulk_with_filters_config")
        @ExcludeMissing
        fun _bulkWithFiltersConfig(): JsonField<BulkWithFiltersConfig> = bulkWithFiltersConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkWithFilters].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkWithFiltersConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [BulkWithFilters]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var bulkWithFiltersConfig: JsonField<BulkWithFiltersConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk_with_filters")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(bulkWithFilters: BulkWithFilters) = apply {
                id = bulkWithFilters.id
                billableMetric = bulkWithFilters.billableMetric
                billingCycleConfiguration = bulkWithFilters.billingCycleConfiguration
                billingMode = bulkWithFilters.billingMode
                bulkWithFiltersConfig = bulkWithFilters.bulkWithFiltersConfig
                cadence = bulkWithFilters.cadence
                compositePriceFilters =
                    bulkWithFilters.compositePriceFilters.map { it.toMutableList() }
                conversionRate = bulkWithFilters.conversionRate
                conversionRateConfig = bulkWithFilters.conversionRateConfig
                createdAt = bulkWithFilters.createdAt
                creditAllocation = bulkWithFilters.creditAllocation
                currency = bulkWithFilters.currency
                discount = bulkWithFilters.discount
                externalPriceId = bulkWithFilters.externalPriceId
                fixedPriceQuantity = bulkWithFilters.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithFilters.invoicingCycleConfiguration
                item = bulkWithFilters.item
                maximum = bulkWithFilters.maximum
                maximumAmount = bulkWithFilters.maximumAmount
                metadata = bulkWithFilters.metadata
                minimum = bulkWithFilters.minimum
                minimumAmount = bulkWithFilters.minimumAmount
                modelType = bulkWithFilters.modelType
                name = bulkWithFilters.name
                planPhaseOrder = bulkWithFilters.planPhaseOrder
                priceType = bulkWithFilters.priceType
                replacesPriceId = bulkWithFilters.replacesPriceId
                dimensionalPriceConfiguration = bulkWithFilters.dimensionalPriceConfiguration
                additionalProperties = bulkWithFilters.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            /** Configuration for bulk_with_filters pricing */
            fun bulkWithFiltersConfig(bulkWithFiltersConfig: BulkWithFiltersConfig) =
                bulkWithFiltersConfig(JsonField.of(bulkWithFiltersConfig))

            /**
             * Sets [Builder.bulkWithFiltersConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkWithFiltersConfig] with a well-typed
             * [BulkWithFiltersConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun bulkWithFiltersConfig(bulkWithFiltersConfig: JsonField<BulkWithFiltersConfig>) =
                apply {
                    this.bulkWithFiltersConfig = bulkWithFiltersConfig
                }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("bulk_with_filters")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [BulkWithFilters].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkWithFiltersConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): BulkWithFilters =
                BulkWithFilters(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("bulkWithFiltersConfig", bulkWithFiltersConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): BulkWithFilters = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            bulkWithFiltersConfig().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk_with_filters")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (bulkWithFiltersConfig.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("bulk_with_filters")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for bulk_with_filters pricing */
        class BulkWithFiltersConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val filters: JsonField<List<Filter>>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("filters")
                @ExcludeMissing
                filters: JsonField<List<Filter>> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(filters, tiers, mutableMapOf())

            /**
             * Property filters to apply (all must match)
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun filters(): List<Filter> = filters.getRequired("filters")

            /**
             * Bulk tiers for rating based on total usage volume
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [filters].
             *
             * Unlike [filters], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("filters")
            @ExcludeMissing
            fun _filters(): JsonField<List<Filter>> = filters

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BulkWithFiltersConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .filters()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [BulkWithFiltersConfig]. */
            class Builder internal constructor() {

                private var filters: JsonField<MutableList<Filter>>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(bulkWithFiltersConfig: BulkWithFiltersConfig) = apply {
                    filters = bulkWithFiltersConfig.filters.map { it.toMutableList() }
                    tiers = bulkWithFiltersConfig.tiers.map { it.toMutableList() }
                    additionalProperties = bulkWithFiltersConfig.additionalProperties.toMutableMap()
                }

                /** Property filters to apply (all must match) */
                fun filters(filters: List<Filter>) = filters(JsonField.of(filters))

                /**
                 * Sets [Builder.filters] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.filters] with a well-typed `List<Filter>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun filters(filters: JsonField<List<Filter>>) = apply {
                    this.filters = filters.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Filter] to [filters].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addFilter(filter: Filter) = apply {
                    filters =
                        (filters ?: JsonField.of(mutableListOf())).also {
                            checkKnown("filters", it).add(filter)
                        }
                }

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [BulkWithFiltersConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .filters()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): BulkWithFiltersConfig =
                    BulkWithFiltersConfig(
                        checkRequired("filters", filters).map { it.toImmutable() },
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): BulkWithFiltersConfig = apply {
                if (validated) {
                    return@apply
                }

                filters().forEach { it.validate() }
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (filters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single property filter */
            class Filter
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val propertyKey: JsonField<String>,
                private val propertyValue: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("property_key")
                    @ExcludeMissing
                    propertyKey: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("property_value")
                    @ExcludeMissing
                    propertyValue: JsonField<String> = JsonMissing.of(),
                ) : this(propertyKey, propertyValue, mutableMapOf())

                /**
                 * Event property key to filter on
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun propertyKey(): String = propertyKey.getRequired("property_key")

                /**
                 * Event property value to match
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun propertyValue(): String = propertyValue.getRequired("property_value")

                /**
                 * Returns the raw JSON value of [propertyKey].
                 *
                 * Unlike [propertyKey], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("property_key")
                @ExcludeMissing
                fun _propertyKey(): JsonField<String> = propertyKey

                /**
                 * Returns the raw JSON value of [propertyValue].
                 *
                 * Unlike [propertyValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("property_value")
                @ExcludeMissing
                fun _propertyValue(): JsonField<String> = propertyValue

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Filter].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .propertyKey()
                     * .propertyValue()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Filter]. */
                class Builder internal constructor() {

                    private var propertyKey: JsonField<String>? = null
                    private var propertyValue: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(filter: Filter) = apply {
                        propertyKey = filter.propertyKey
                        propertyValue = filter.propertyValue
                        additionalProperties = filter.additionalProperties.toMutableMap()
                    }

                    /** Event property key to filter on */
                    fun propertyKey(propertyKey: String) = propertyKey(JsonField.of(propertyKey))

                    /**
                     * Sets [Builder.propertyKey] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.propertyKey] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun propertyKey(propertyKey: JsonField<String>) = apply {
                        this.propertyKey = propertyKey
                    }

                    /** Event property value to match */
                    fun propertyValue(propertyValue: String) =
                        propertyValue(JsonField.of(propertyValue))

                    /**
                     * Sets [Builder.propertyValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.propertyValue] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun propertyValue(propertyValue: JsonField<String>) = apply {
                        this.propertyValue = propertyValue
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Filter].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .propertyKey()
                     * .propertyValue()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Filter =
                        Filter(
                            checkRequired("propertyKey", propertyKey),
                            checkRequired("propertyValue", propertyValue),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Filter = apply {
                    if (validated) {
                        return@apply
                    }

                    propertyKey()
                    propertyValue()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (propertyKey.asKnown() == null) 0 else 1) +
                        (if (propertyValue.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Filter &&
                        propertyKey == other.propertyKey &&
                        propertyValue == other.propertyValue &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(propertyKey, propertyValue, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Filter{propertyKey=$propertyKey, propertyValue=$propertyValue, additionalProperties=$additionalProperties}"
            }

            /** Configuration for a single bulk pricing tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val unitAmount: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                ) : this(unitAmount, tierLowerBound, mutableMapOf())

                /**
                 * Amount per unit
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * The lower bound for this tier
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun tierLowerBound(): String? = tierLowerBound.getNullable("tier_lower_bound")

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var unitAmount: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        unitAmount = tier.unitAmount
                        tierLowerBound = tier.tierLowerBound
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** The lower bound for this tier */
                    fun tierLowerBound(tierLowerBound: String?) =
                        tierLowerBound(JsonField.ofNullable(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("unitAmount", unitAmount),
                            tierLowerBound,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    unitAmount()
                    tierLowerBound()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (unitAmount.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        unitAmount == other.unitAmount &&
                        tierLowerBound == other.tierLowerBound &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(unitAmount, tierLowerBound, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{unitAmount=$unitAmount, tierLowerBound=$tierLowerBound, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BulkWithFiltersConfig &&
                    filters == other.filters &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(filters, tiers, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkWithFiltersConfig{filters=$filters, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is BulkWithFilters &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                bulkWithFiltersConfig == other.bulkWithFiltersConfig &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                bulkWithFiltersConfig,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithFilters{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, bulkWithFiltersConfig=$bulkWithFiltersConfig, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Package
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val packageConfig: JsonField<PackageConfig>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_config")
            @ExcludeMissing
            packageConfig: JsonField<PackageConfig> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            packageConfig,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * Configuration for package pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageConfig].
         *
         * Unlike [packageConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfig> = packageConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Package].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Package]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("package")
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(package_: Package) = apply {
                id = package_.id
                billableMetric = package_.billableMetric
                billingCycleConfiguration = package_.billingCycleConfiguration
                billingMode = package_.billingMode
                cadence = package_.cadence
                compositePriceFilters = package_.compositePriceFilters.map { it.toMutableList() }
                conversionRate = package_.conversionRate
                conversionRateConfig = package_.conversionRateConfig
                createdAt = package_.createdAt
                creditAllocation = package_.creditAllocation
                currency = package_.currency
                discount = package_.discount
                externalPriceId = package_.externalPriceId
                fixedPriceQuantity = package_.fixedPriceQuantity
                invoicingCycleConfiguration = package_.invoicingCycleConfiguration
                item = package_.item
                maximum = package_.maximum
                maximumAmount = package_.maximumAmount
                metadata = package_.metadata
                minimum = package_.minimum
                minimumAmount = package_.minimumAmount
                modelType = package_.modelType
                name = package_.name
                packageConfig = package_.packageConfig
                planPhaseOrder = package_.planPhaseOrder
                priceType = package_.priceType
                replacesPriceId = package_.replacesPriceId
                dimensionalPriceConfiguration = package_.dimensionalPriceConfiguration
                additionalProperties = package_.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /** Configuration for package pricing */
            fun packageConfig(packageConfig: PackageConfig) =
                packageConfig(JsonField.of(packageConfig))

            /**
             * Sets [Builder.packageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageConfig] with a well-typed [PackageConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                this.packageConfig = packageConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Package].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Package =
                Package(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Package = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            packageConfig().validate()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("package")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (packageConfig.asKnown()?.validity() ?: 0) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Package &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                packageConfig == other.packageConfig &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                packageConfig,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Package{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageConfig=$packageConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Matrix
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixConfig: JsonField<MatrixConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_config")
            @ExcludeMissing
            matrixConfig: JsonField<MatrixConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * Configuration for matrix pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("matrix")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixConfig].
         *
         * Unlike [matrixConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfig> = matrixConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Matrix].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Matrix]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixConfig: JsonField<MatrixConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(matrix: Matrix) = apply {
                id = matrix.id
                billableMetric = matrix.billableMetric
                billingCycleConfiguration = matrix.billingCycleConfiguration
                billingMode = matrix.billingMode
                cadence = matrix.cadence
                compositePriceFilters = matrix.compositePriceFilters.map { it.toMutableList() }
                conversionRate = matrix.conversionRate
                conversionRateConfig = matrix.conversionRateConfig
                createdAt = matrix.createdAt
                creditAllocation = matrix.creditAllocation
                currency = matrix.currency
                discount = matrix.discount
                externalPriceId = matrix.externalPriceId
                fixedPriceQuantity = matrix.fixedPriceQuantity
                invoicingCycleConfiguration = matrix.invoicingCycleConfiguration
                item = matrix.item
                matrixConfig = matrix.matrixConfig
                maximum = matrix.maximum
                maximumAmount = matrix.maximumAmount
                metadata = matrix.metadata
                minimum = matrix.minimum
                minimumAmount = matrix.minimumAmount
                modelType = matrix.modelType
                name = matrix.name
                planPhaseOrder = matrix.planPhaseOrder
                priceType = matrix.priceType
                replacesPriceId = matrix.replacesPriceId
                dimensionalPriceConfiguration = matrix.dimensionalPriceConfiguration
                additionalProperties = matrix.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            /** Configuration for matrix pricing */
            fun matrixConfig(matrixConfig: MatrixConfig) = matrixConfig(JsonField.of(matrixConfig))

            /**
             * Sets [Builder.matrixConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixConfig] with a well-typed [MatrixConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                this.matrixConfig = matrixConfig
            }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("matrix")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Matrix].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Matrix =
                Matrix(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Matrix = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            matrixConfig().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (matrixConfig.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("matrix")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Matrix &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                matrixConfig == other.matrixConfig &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                matrixConfig,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Matrix{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixConfig=$matrixConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ThresholdTotalAmount
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("threshold_total_amount_config")
            @ExcludeMissing
            thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            thresholdTotalAmountConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("threshold_total_amount")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for threshold_total_amount pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [thresholdTotalAmountConfig].
         *
         * Unlike [thresholdTotalAmountConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<ThresholdTotalAmountConfig> =
            thresholdTotalAmountConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [ThresholdTotalAmount].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .thresholdTotalAmountConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [ThresholdTotalAmount]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("threshold_total_amount")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(thresholdTotalAmount: ThresholdTotalAmount) = apply {
                id = thresholdTotalAmount.id
                billableMetric = thresholdTotalAmount.billableMetric
                billingCycleConfiguration = thresholdTotalAmount.billingCycleConfiguration
                billingMode = thresholdTotalAmount.billingMode
                cadence = thresholdTotalAmount.cadence
                compositePriceFilters =
                    thresholdTotalAmount.compositePriceFilters.map { it.toMutableList() }
                conversionRate = thresholdTotalAmount.conversionRate
                conversionRateConfig = thresholdTotalAmount.conversionRateConfig
                createdAt = thresholdTotalAmount.createdAt
                creditAllocation = thresholdTotalAmount.creditAllocation
                currency = thresholdTotalAmount.currency
                discount = thresholdTotalAmount.discount
                externalPriceId = thresholdTotalAmount.externalPriceId
                fixedPriceQuantity = thresholdTotalAmount.fixedPriceQuantity
                invoicingCycleConfiguration = thresholdTotalAmount.invoicingCycleConfiguration
                item = thresholdTotalAmount.item
                maximum = thresholdTotalAmount.maximum
                maximumAmount = thresholdTotalAmount.maximumAmount
                metadata = thresholdTotalAmount.metadata
                minimum = thresholdTotalAmount.minimum
                minimumAmount = thresholdTotalAmount.minimumAmount
                modelType = thresholdTotalAmount.modelType
                name = thresholdTotalAmount.name
                planPhaseOrder = thresholdTotalAmount.planPhaseOrder
                priceType = thresholdTotalAmount.priceType
                replacesPriceId = thresholdTotalAmount.replacesPriceId
                thresholdTotalAmountConfig = thresholdTotalAmount.thresholdTotalAmountConfig
                dimensionalPriceConfiguration = thresholdTotalAmount.dimensionalPriceConfiguration
                additionalProperties = thresholdTotalAmount.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("threshold_total_amount")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for threshold_total_amount pricing */
            fun thresholdTotalAmountConfig(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            /**
             * Sets [Builder.thresholdTotalAmountConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.thresholdTotalAmountConfig] with a well-typed
             * [ThresholdTotalAmountConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ThresholdTotalAmount].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .thresholdTotalAmountConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ThresholdTotalAmount =
                ThresholdTotalAmount(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ThresholdTotalAmount = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("threshold_total_amount")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            thresholdTotalAmountConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("threshold_total_amount")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (thresholdTotalAmountConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for threshold_total_amount pricing */
        class ThresholdTotalAmountConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val consumptionTable: JsonField<List<ConsumptionTable>>,
            private val prorate: JsonField<Boolean>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("consumption_table")
                @ExcludeMissing
                consumptionTable: JsonField<List<ConsumptionTable>> = JsonMissing.of(),
                @JsonProperty("prorate")
                @ExcludeMissing
                prorate: JsonField<Boolean> = JsonMissing.of(),
            ) : this(consumptionTable, prorate, mutableMapOf())

            /**
             * When the quantity consumed passes a provided threshold, the configured total will be
             * charged
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun consumptionTable(): List<ConsumptionTable> =
                consumptionTable.getRequired("consumption_table")

            /**
             * If true, the unit price will be prorated to the billing period
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun prorate(): Boolean? = prorate.getNullable("prorate")

            /**
             * Returns the raw JSON value of [consumptionTable].
             *
             * Unlike [consumptionTable], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("consumption_table")
            @ExcludeMissing
            fun _consumptionTable(): JsonField<List<ConsumptionTable>> = consumptionTable

            /**
             * Returns the raw JSON value of [prorate].
             *
             * Unlike [prorate], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("prorate") @ExcludeMissing fun _prorate(): JsonField<Boolean> = prorate

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ThresholdTotalAmountConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .consumptionTable()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [ThresholdTotalAmountConfig]. */
            class Builder internal constructor() {

                private var consumptionTable: JsonField<MutableList<ConsumptionTable>>? = null
                private var prorate: JsonField<Boolean> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) = apply {
                    consumptionTable =
                        thresholdTotalAmountConfig.consumptionTable.map { it.toMutableList() }
                    prorate = thresholdTotalAmountConfig.prorate
                    additionalProperties =
                        thresholdTotalAmountConfig.additionalProperties.toMutableMap()
                }

                /**
                 * When the quantity consumed passes a provided threshold, the configured total will
                 * be charged
                 */
                fun consumptionTable(consumptionTable: List<ConsumptionTable>) =
                    consumptionTable(JsonField.of(consumptionTable))

                /**
                 * Sets [Builder.consumptionTable] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumptionTable] with a well-typed
                 * `List<ConsumptionTable>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun consumptionTable(consumptionTable: JsonField<List<ConsumptionTable>>) = apply {
                    this.consumptionTable = consumptionTable.map { it.toMutableList() }
                }

                /**
                 * Adds a single [ConsumptionTable] to [Builder.consumptionTable].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addConsumptionTable(consumptionTable: ConsumptionTable) = apply {
                    this.consumptionTable =
                        (this.consumptionTable ?: JsonField.of(mutableListOf())).also {
                            checkKnown("consumptionTable", it).add(consumptionTable)
                        }
                }

                /** If true, the unit price will be prorated to the billing period */
                fun prorate(prorate: Boolean?) = prorate(JsonField.ofNullable(prorate))

                /**
                 * Alias for [Builder.prorate].
                 *
                 * This unboxed primitive overload exists for backwards compatibility.
                 */
                fun prorate(prorate: Boolean) = prorate(prorate as Boolean?)

                /**
                 * Sets [Builder.prorate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.prorate] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun prorate(prorate: JsonField<Boolean>) = apply { this.prorate = prorate }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ThresholdTotalAmountConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .consumptionTable()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): ThresholdTotalAmountConfig =
                    ThresholdTotalAmountConfig(
                        checkRequired("consumptionTable", consumptionTable).map {
                            it.toImmutable()
                        },
                        prorate,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): ThresholdTotalAmountConfig = apply {
                if (validated) {
                    return@apply
                }

                consumptionTable().forEach { it.validate() }
                prorate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (consumptionTable.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (prorate.asKnown() == null) 0 else 1)

            /** Configuration for a single threshold */
            class ConsumptionTable
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val threshold: JsonField<String>,
                private val totalAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("threshold")
                    @ExcludeMissing
                    threshold: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("total_amount")
                    @ExcludeMissing
                    totalAmount: JsonField<String> = JsonMissing.of(),
                ) : this(threshold, totalAmount, mutableMapOf())

                /**
                 * Quantity threshold
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun threshold(): String = threshold.getRequired("threshold")

                /**
                 * Total amount for this threshold
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun totalAmount(): String = totalAmount.getRequired("total_amount")

                /**
                 * Returns the raw JSON value of [threshold].
                 *
                 * Unlike [threshold], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("threshold")
                @ExcludeMissing
                fun _threshold(): JsonField<String> = threshold

                /**
                 * Returns the raw JSON value of [totalAmount].
                 *
                 * Unlike [totalAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("total_amount")
                @ExcludeMissing
                fun _totalAmount(): JsonField<String> = totalAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [ConsumptionTable].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .threshold()
                     * .totalAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumptionTable]. */
                class Builder internal constructor() {

                    private var threshold: JsonField<String>? = null
                    private var totalAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumptionTable: ConsumptionTable) = apply {
                        threshold = consumptionTable.threshold
                        totalAmount = consumptionTable.totalAmount
                        additionalProperties = consumptionTable.additionalProperties.toMutableMap()
                    }

                    /** Quantity threshold */
                    fun threshold(threshold: String) = threshold(JsonField.of(threshold))

                    /**
                     * Sets [Builder.threshold] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.threshold] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun threshold(threshold: JsonField<String>) = apply {
                        this.threshold = threshold
                    }

                    /** Total amount for this threshold */
                    fun totalAmount(totalAmount: String) = totalAmount(JsonField.of(totalAmount))

                    /**
                     * Sets [Builder.totalAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.totalAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun totalAmount(totalAmount: JsonField<String>) = apply {
                        this.totalAmount = totalAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumptionTable].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .threshold()
                     * .totalAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumptionTable =
                        ConsumptionTable(
                            checkRequired("threshold", threshold),
                            checkRequired("totalAmount", totalAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumptionTable = apply {
                    if (validated) {
                        return@apply
                    }

                    threshold()
                    totalAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (threshold.asKnown() == null) 0 else 1) +
                        (if (totalAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumptionTable &&
                        threshold == other.threshold &&
                        totalAmount == other.totalAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(threshold, totalAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumptionTable{threshold=$threshold, totalAmount=$totalAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is ThresholdTotalAmountConfig &&
                    consumptionTable == other.consumptionTable &&
                    prorate == other.prorate &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(consumptionTable, prorate, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ThresholdTotalAmountConfig{consumptionTable=$consumptionTable, prorate=$prorate, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ThresholdTotalAmount &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                thresholdTotalAmountConfig == other.thresholdTotalAmountConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                thresholdTotalAmountConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ThresholdTotalAmount{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredPackage
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredPackageConfig: JsonField<TieredPackageConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_package_config")
            @ExcludeMissing
            tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredPackageConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for tiered_package pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageConfig(): TieredPackageConfig =
            tieredPackageConfig.getRequired("tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredPackageConfig].
         *
         * Unlike [tieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<TieredPackageConfig> = tieredPackageConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackage].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [TieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredPackageConfig: JsonField<TieredPackageConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(tieredPackage: TieredPackage) = apply {
                id = tieredPackage.id
                billableMetric = tieredPackage.billableMetric
                billingCycleConfiguration = tieredPackage.billingCycleConfiguration
                billingMode = tieredPackage.billingMode
                cadence = tieredPackage.cadence
                compositePriceFilters =
                    tieredPackage.compositePriceFilters.map { it.toMutableList() }
                conversionRate = tieredPackage.conversionRate
                conversionRateConfig = tieredPackage.conversionRateConfig
                createdAt = tieredPackage.createdAt
                creditAllocation = tieredPackage.creditAllocation
                currency = tieredPackage.currency
                discount = tieredPackage.discount
                externalPriceId = tieredPackage.externalPriceId
                fixedPriceQuantity = tieredPackage.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackage.invoicingCycleConfiguration
                item = tieredPackage.item
                maximum = tieredPackage.maximum
                maximumAmount = tieredPackage.maximumAmount
                metadata = tieredPackage.metadata
                minimum = tieredPackage.minimum
                minimumAmount = tieredPackage.minimumAmount
                modelType = tieredPackage.modelType
                name = tieredPackage.name
                planPhaseOrder = tieredPackage.planPhaseOrder
                priceType = tieredPackage.priceType
                replacesPriceId = tieredPackage.replacesPriceId
                tieredPackageConfig = tieredPackage.tieredPackageConfig
                dimensionalPriceConfiguration = tieredPackage.dimensionalPriceConfiguration
                additionalProperties = tieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for tiered_package pricing */
            fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            /**
             * Sets [Builder.tieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageConfig] with a well-typed
             * [TieredPackageConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) = apply {
                this.tieredPackageConfig = tieredPackageConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredPackage =
                TieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredPackageConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("tiered_package")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (tieredPackageConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for tiered_package pricing */
        class TieredPackageConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val packageSize: JsonField<String>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("package_size")
                @ExcludeMissing
                packageSize: JsonField<String> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(packageSize, tiers, mutableMapOf())

            /**
             * Package size
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): String = packageSize.getRequired("package_size")

            /**
             * Apply tiered pricing after rounding up the quantity to the package size. Tiers are
             * defined using exclusive lower bounds. The tier bounds are defined based on the total
             * quantity rather than the number of packages, so they must be multiples of the package
             * size.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<String> = packageSize

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [TieredPackageConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .packageSize()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [TieredPackageConfig]. */
            class Builder internal constructor() {

                private var packageSize: JsonField<String>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                    packageSize = tieredPackageConfig.packageSize
                    tiers = tieredPackageConfig.tiers.map { it.toMutableList() }
                    additionalProperties = tieredPackageConfig.additionalProperties.toMutableMap()
                }

                /** Package size */
                fun packageSize(packageSize: String) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<String>) = apply {
                    this.packageSize = packageSize
                }

                /**
                 * Apply tiered pricing after rounding up the quantity to the package size. Tiers
                 * are defined using exclusive lower bounds. The tier bounds are defined based on
                 * the total quantity rather than the number of packages, so they must be multiples
                 * of the package size.
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .packageSize()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): TieredPackageConfig =
                    TieredPackageConfig(
                        checkRequired("packageSize", packageSize),
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): TieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                packageSize()
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (packageSize.asKnown() == null) 0 else 1) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tier with business logic */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val perUnit: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("per_unit")
                    @ExcludeMissing
                    perUnit: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                ) : this(perUnit, tierLowerBound, mutableMapOf())

                /**
                 * Price per package
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun perUnit(): String = perUnit.getRequired("per_unit")

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Returns the raw JSON value of [perUnit].
                 *
                 * Unlike [perUnit], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("per_unit")
                @ExcludeMissing
                fun _perUnit(): JsonField<String> = perUnit

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var perUnit: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        perUnit = tier.perUnit
                        tierLowerBound = tier.tierLowerBound
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Price per package */
                    fun perUnit(perUnit: String) = perUnit(JsonField.of(perUnit))

                    /**
                     * Sets [Builder.perUnit] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.perUnit] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun perUnit(perUnit: JsonField<String>) = apply { this.perUnit = perUnit }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("perUnit", perUnit),
                            checkRequired("tierLowerBound", tierLowerBound),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    perUnit()
                    tierLowerBound()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (perUnit.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        perUnit == other.perUnit &&
                        tierLowerBound == other.tierLowerBound &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(perUnit, tierLowerBound, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{perUnit=$perUnit, tierLowerBound=$tierLowerBound, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is TieredPackageConfig &&
                    packageSize == other.packageSize &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(packageSize, tiers, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageConfig{packageSize=$packageSize, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is TieredPackage &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                tieredPackageConfig == other.tieredPackageConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                tieredPackageConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredPackageConfig=$tieredPackageConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredWithMinimum
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_with_minimum_config")
            @ExcludeMissing
            tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredWithMinimumConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("tiered_with_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for tiered_with_minimum pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredWithMinimumConfig].
         *
         * Unlike [tieredWithMinimumConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<TieredWithMinimumConfig> = tieredWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithMinimum].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithMinimumConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [TieredWithMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_with_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(tieredWithMinimum: TieredWithMinimum) = apply {
                id = tieredWithMinimum.id
                billableMetric = tieredWithMinimum.billableMetric
                billingCycleConfiguration = tieredWithMinimum.billingCycleConfiguration
                billingMode = tieredWithMinimum.billingMode
                cadence = tieredWithMinimum.cadence
                compositePriceFilters =
                    tieredWithMinimum.compositePriceFilters.map { it.toMutableList() }
                conversionRate = tieredWithMinimum.conversionRate
                conversionRateConfig = tieredWithMinimum.conversionRateConfig
                createdAt = tieredWithMinimum.createdAt
                creditAllocation = tieredWithMinimum.creditAllocation
                currency = tieredWithMinimum.currency
                discount = tieredWithMinimum.discount
                externalPriceId = tieredWithMinimum.externalPriceId
                fixedPriceQuantity = tieredWithMinimum.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithMinimum.invoicingCycleConfiguration
                item = tieredWithMinimum.item
                maximum = tieredWithMinimum.maximum
                maximumAmount = tieredWithMinimum.maximumAmount
                metadata = tieredWithMinimum.metadata
                minimum = tieredWithMinimum.minimum
                minimumAmount = tieredWithMinimum.minimumAmount
                modelType = tieredWithMinimum.modelType
                name = tieredWithMinimum.name
                planPhaseOrder = tieredWithMinimum.planPhaseOrder
                priceType = tieredWithMinimum.priceType
                replacesPriceId = tieredWithMinimum.replacesPriceId
                tieredWithMinimumConfig = tieredWithMinimum.tieredWithMinimumConfig
                dimensionalPriceConfiguration = tieredWithMinimum.dimensionalPriceConfiguration
                additionalProperties = tieredWithMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("tiered_with_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for tiered_with_minimum pricing */
            fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            /**
             * Sets [Builder.tieredWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithMinimumConfig] with a well-typed
             * [TieredWithMinimumConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredWithMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithMinimumConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredWithMinimum =
                TieredWithMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredWithMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_with_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredWithMinimumConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("tiered_with_minimum")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (tieredWithMinimumConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for tiered_with_minimum pricing */
        class TieredWithMinimumConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val tiers: JsonField<List<Tier>>,
            private val hideZeroAmountTiers: JsonField<Boolean>,
            private val prorate: JsonField<Boolean>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
                @JsonProperty("hide_zero_amount_tiers")
                @ExcludeMissing
                hideZeroAmountTiers: JsonField<Boolean> = JsonMissing.of(),
                @JsonProperty("prorate")
                @ExcludeMissing
                prorate: JsonField<Boolean> = JsonMissing.of(),
            ) : this(tiers, hideZeroAmountTiers, prorate, mutableMapOf())

            /**
             * Tiered pricing with a minimum amount dependent on the volume tier. Tiers are defined
             * using exclusive lower bounds.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * If true, tiers with an accrued amount of 0 will not be included in the rating.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun hideZeroAmountTiers(): Boolean? =
                hideZeroAmountTiers.getNullable("hide_zero_amount_tiers")

            /**
             * If true, the unit price will be prorated to the billing period
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun prorate(): Boolean? = prorate.getNullable("prorate")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            /**
             * Returns the raw JSON value of [hideZeroAmountTiers].
             *
             * Unlike [hideZeroAmountTiers], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("hide_zero_amount_tiers")
            @ExcludeMissing
            fun _hideZeroAmountTiers(): JsonField<Boolean> = hideZeroAmountTiers

            /**
             * Returns the raw JSON value of [prorate].
             *
             * Unlike [prorate], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("prorate") @ExcludeMissing fun _prorate(): JsonField<Boolean> = prorate

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithMinimumConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [TieredWithMinimumConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var hideZeroAmountTiers: JsonField<Boolean> = JsonMissing.of()
                private var prorate: JsonField<Boolean> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                    tiers = tieredWithMinimumConfig.tiers.map { it.toMutableList() }
                    hideZeroAmountTiers = tieredWithMinimumConfig.hideZeroAmountTiers
                    prorate = tieredWithMinimumConfig.prorate
                    additionalProperties =
                        tieredWithMinimumConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiered pricing with a minimum amount dependent on the volume tier. Tiers are
                 * defined using exclusive lower bounds.
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                /**
                 * If true, tiers with an accrued amount of 0 will not be included in the rating.
                 */
                fun hideZeroAmountTiers(hideZeroAmountTiers: Boolean) =
                    hideZeroAmountTiers(JsonField.of(hideZeroAmountTiers))

                /**
                 * Sets [Builder.hideZeroAmountTiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.hideZeroAmountTiers] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun hideZeroAmountTiers(hideZeroAmountTiers: JsonField<Boolean>) = apply {
                    this.hideZeroAmountTiers = hideZeroAmountTiers
                }

                /** If true, the unit price will be prorated to the billing period */
                fun prorate(prorate: Boolean) = prorate(JsonField.of(prorate))

                /**
                 * Sets [Builder.prorate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.prorate] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun prorate(prorate: JsonField<Boolean>) = apply { this.prorate = prorate }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredWithMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): TieredWithMinimumConfig =
                    TieredWithMinimumConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        hideZeroAmountTiers,
                        prorate,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): TieredWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                hideZeroAmountTiers()
                prorate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (hideZeroAmountTiers.asKnown() == null) 0 else 1) +
                    (if (prorate.asKnown() == null) 0 else 1)

            /** Configuration for a single tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val minimumAmount: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    minimumAmount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(minimumAmount, tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Minimum amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [minimumAmount].
                 *
                 * Unlike [minimumAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun _minimumAmount(): JsonField<String> = minimumAmount

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .minimumAmount()
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var minimumAmount: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        minimumAmount = tier.minimumAmount
                        tierLowerBound = tier.tierLowerBound
                        unitAmount = tier.unitAmount
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Minimum amount */
                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    /**
                     * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.minimumAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .minimumAmount()
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("minimumAmount", minimumAmount),
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    minimumAmount()
                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (minimumAmount.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        minimumAmount == other.minimumAmount &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(minimumAmount, tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{minimumAmount=$minimumAmount, tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is TieredWithMinimumConfig &&
                    tiers == other.tiers &&
                    hideZeroAmountTiers == other.hideZeroAmountTiers &&
                    prorate == other.prorate &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(tiers, hideZeroAmountTiers, prorate, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithMinimumConfig{tiers=$tiers, hideZeroAmountTiers=$hideZeroAmountTiers, prorate=$prorate, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is TieredWithMinimum &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                tieredWithMinimumConfig == other.tieredWithMinimumConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                tieredWithMinimumConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredWithMinimumConfig=$tieredWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedTiered
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedTieredConfig: JsonField<GroupedTieredConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_tiered_config")
            @ExcludeMissing
            groupedTieredConfig: JsonField<GroupedTieredConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedTieredConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_tiered pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredConfig(): GroupedTieredConfig =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_tiered")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredConfig].
         *
         * Unlike [groupedTieredConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<GroupedTieredConfig> = groupedTieredConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTiered].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedTiered]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredConfig: JsonField<GroupedTieredConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_tiered")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedTiered: GroupedTiered) = apply {
                id = groupedTiered.id
                billableMetric = groupedTiered.billableMetric
                billingCycleConfiguration = groupedTiered.billingCycleConfiguration
                billingMode = groupedTiered.billingMode
                cadence = groupedTiered.cadence
                compositePriceFilters =
                    groupedTiered.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedTiered.conversionRate
                conversionRateConfig = groupedTiered.conversionRateConfig
                createdAt = groupedTiered.createdAt
                creditAllocation = groupedTiered.creditAllocation
                currency = groupedTiered.currency
                discount = groupedTiered.discount
                externalPriceId = groupedTiered.externalPriceId
                fixedPriceQuantity = groupedTiered.fixedPriceQuantity
                groupedTieredConfig = groupedTiered.groupedTieredConfig
                invoicingCycleConfiguration = groupedTiered.invoicingCycleConfiguration
                item = groupedTiered.item
                maximum = groupedTiered.maximum
                maximumAmount = groupedTiered.maximumAmount
                metadata = groupedTiered.metadata
                minimum = groupedTiered.minimum
                minimumAmount = groupedTiered.minimumAmount
                modelType = groupedTiered.modelType
                name = groupedTiered.name
                planPhaseOrder = groupedTiered.planPhaseOrder
                priceType = groupedTiered.priceType
                replacesPriceId = groupedTiered.replacesPriceId
                dimensionalPriceConfiguration = groupedTiered.dimensionalPriceConfiguration
                additionalProperties = groupedTiered.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_tiered pricing */
            fun groupedTieredConfig(groupedTieredConfig: GroupedTieredConfig) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            /**
             * Sets [Builder.groupedTieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredConfig] with a well-typed
             * [GroupedTieredConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun groupedTieredConfig(groupedTieredConfig: JsonField<GroupedTieredConfig>) = apply {
                this.groupedTieredConfig = groupedTieredConfig
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_tiered")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedTiered].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedTiered =
                GroupedTiered(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedTiered = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_tiered")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedTieredConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("grouped_tiered")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_tiered pricing */
        class GroupedTieredConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(groupingKey, tiers, mutableMapOf())

            /**
             * The billable metric property used to group before tiering
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * Apply tiered pricing to each segment generated after grouping with the provided key
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [GroupedTieredConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedTieredConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(groupedTieredConfig: GroupedTieredConfig) = apply {
                    groupingKey = groupedTieredConfig.groupingKey
                    tiers = groupedTieredConfig.tiers.map { it.toMutableList() }
                    additionalProperties = groupedTieredConfig.additionalProperties.toMutableMap()
                }

                /** The billable metric property used to group before tiering */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /**
                 * Apply tiered pricing to each segment generated after grouping with the provided
                 * key
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedTieredConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedTieredConfig =
                    GroupedTieredConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedTieredConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        tierLowerBound = tier.tierLowerBound
                        unitAmount = tier.unitAmount
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedTieredConfig &&
                    groupingKey == other.groupingKey &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(groupingKey, tiers, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredConfig{groupingKey=$groupingKey, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedTiered &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedTieredConfig == other.groupedTieredConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedTieredConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTiered{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredConfig=$groupedTieredConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredPackageWithMinimum
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_package_with_minimum_config")
            @ExcludeMissing
            tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredPackageWithMinimumConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("tiered_package_with_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for tiered_package_with_minimum pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageWithMinimumConfig(): TieredPackageWithMinimumConfig =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredPackageWithMinimumConfig].
         *
         * Unlike [tieredPackageWithMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<TieredPackageWithMinimumConfig> =
            tieredPackageWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackageWithMinimum].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageWithMinimumConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [TieredPackageWithMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_package_with_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(tieredPackageWithMinimum: TieredPackageWithMinimum) = apply {
                id = tieredPackageWithMinimum.id
                billableMetric = tieredPackageWithMinimum.billableMetric
                billingCycleConfiguration = tieredPackageWithMinimum.billingCycleConfiguration
                billingMode = tieredPackageWithMinimum.billingMode
                cadence = tieredPackageWithMinimum.cadence
                compositePriceFilters =
                    tieredPackageWithMinimum.compositePriceFilters.map { it.toMutableList() }
                conversionRate = tieredPackageWithMinimum.conversionRate
                conversionRateConfig = tieredPackageWithMinimum.conversionRateConfig
                createdAt = tieredPackageWithMinimum.createdAt
                creditAllocation = tieredPackageWithMinimum.creditAllocation
                currency = tieredPackageWithMinimum.currency
                discount = tieredPackageWithMinimum.discount
                externalPriceId = tieredPackageWithMinimum.externalPriceId
                fixedPriceQuantity = tieredPackageWithMinimum.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackageWithMinimum.invoicingCycleConfiguration
                item = tieredPackageWithMinimum.item
                maximum = tieredPackageWithMinimum.maximum
                maximumAmount = tieredPackageWithMinimum.maximumAmount
                metadata = tieredPackageWithMinimum.metadata
                minimum = tieredPackageWithMinimum.minimum
                minimumAmount = tieredPackageWithMinimum.minimumAmount
                modelType = tieredPackageWithMinimum.modelType
                name = tieredPackageWithMinimum.name
                planPhaseOrder = tieredPackageWithMinimum.planPhaseOrder
                priceType = tieredPackageWithMinimum.priceType
                replacesPriceId = tieredPackageWithMinimum.replacesPriceId
                tieredPackageWithMinimumConfig =
                    tieredPackageWithMinimum.tieredPackageWithMinimumConfig
                dimensionalPriceConfiguration =
                    tieredPackageWithMinimum.dimensionalPriceConfiguration
                additionalProperties = tieredPackageWithMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("tiered_package_with_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for tiered_package_with_minimum pricing */
            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            /**
             * Sets [Builder.tieredPackageWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageWithMinimumConfig] with a well-typed
             * [TieredPackageWithMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredPackageWithMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageWithMinimumConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredPackageWithMinimum =
                TieredPackageWithMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredPackageWithMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_package_with_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredPackageWithMinimumConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("tiered_package_with_minimum")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (tieredPackageWithMinimumConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for tiered_package_with_minimum pricing */
        class TieredPackageWithMinimumConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val packageSize: JsonField<Double>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("package_size")
                @ExcludeMissing
                packageSize: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(packageSize, tiers, mutableMapOf())

            /**
             * Package size
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): Double = packageSize.getRequired("package_size")

            /**
             * Apply tiered pricing after rounding up the quantity to the package size. Tiers are
             * defined using exclusive lower bounds.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<Double> = packageSize

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredPackageWithMinimumConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .packageSize()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [TieredPackageWithMinimumConfig]. */
            class Builder internal constructor() {

                private var packageSize: JsonField<Double>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig) =
                    apply {
                        packageSize = tieredPackageWithMinimumConfig.packageSize
                        tiers = tieredPackageWithMinimumConfig.tiers.map { it.toMutableList() }
                        additionalProperties =
                            tieredPackageWithMinimumConfig.additionalProperties.toMutableMap()
                    }

                /** Package size */
                fun packageSize(packageSize: Double) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [Double] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<Double>) = apply {
                    this.packageSize = packageSize
                }

                /**
                 * Apply tiered pricing after rounding up the quantity to the package size. Tiers
                 * are defined using exclusive lower bounds.
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredPackageWithMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .packageSize()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): TieredPackageWithMinimumConfig =
                    TieredPackageWithMinimumConfig(
                        checkRequired("packageSize", packageSize),
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): TieredPackageWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                packageSize()
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (packageSize.asKnown() == null) 0 else 1) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val minimumAmount: JsonField<String>,
                private val perUnit: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("minimum_amount")
                    @ExcludeMissing
                    minimumAmount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("per_unit")
                    @ExcludeMissing
                    perUnit: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                ) : this(minimumAmount, perUnit, tierLowerBound, mutableMapOf())

                /**
                 * Minimum amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /**
                 * Price per package
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun perUnit(): String = perUnit.getRequired("per_unit")

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Returns the raw JSON value of [minimumAmount].
                 *
                 * Unlike [minimumAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun _minimumAmount(): JsonField<String> = minimumAmount

                /**
                 * Returns the raw JSON value of [perUnit].
                 *
                 * Unlike [perUnit], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("per_unit")
                @ExcludeMissing
                fun _perUnit(): JsonField<String> = perUnit

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .minimumAmount()
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var minimumAmount: JsonField<String>? = null
                    private var perUnit: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        minimumAmount = tier.minimumAmount
                        perUnit = tier.perUnit
                        tierLowerBound = tier.tierLowerBound
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Minimum amount */
                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    /**
                     * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.minimumAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** Price per package */
                    fun perUnit(perUnit: String) = perUnit(JsonField.of(perUnit))

                    /**
                     * Sets [Builder.perUnit] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.perUnit] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun perUnit(perUnit: JsonField<String>) = apply { this.perUnit = perUnit }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .minimumAmount()
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("minimumAmount", minimumAmount),
                            checkRequired("perUnit", perUnit),
                            checkRequired("tierLowerBound", tierLowerBound),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    minimumAmount()
                    perUnit()
                    tierLowerBound()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (minimumAmount.asKnown() == null) 0 else 1) +
                        (if (perUnit.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        minimumAmount == other.minimumAmount &&
                        perUnit == other.perUnit &&
                        tierLowerBound == other.tierLowerBound &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(minimumAmount, perUnit, tierLowerBound, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{minimumAmount=$minimumAmount, perUnit=$perUnit, tierLowerBound=$tierLowerBound, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is TieredPackageWithMinimumConfig &&
                    packageSize == other.packageSize &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(packageSize, tiers, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageWithMinimumConfig{packageSize=$packageSize, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is TieredPackageWithMinimum &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                tieredPackageWithMinimumConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackageWithMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class PackageWithAllocation
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_with_allocation_config")
            @ExcludeMissing
            packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            packageWithAllocationConfig,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("package_with_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * Configuration for package_with_allocation pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageWithAllocationConfig(): PackageWithAllocationConfig =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageWithAllocationConfig].
         *
         * Unlike [packageWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<PackageWithAllocationConfig> =
            packageWithAllocationConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [PackageWithAllocation].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [PackageWithAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("package_with_allocation")
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(packageWithAllocation: PackageWithAllocation) = apply {
                id = packageWithAllocation.id
                billableMetric = packageWithAllocation.billableMetric
                billingCycleConfiguration = packageWithAllocation.billingCycleConfiguration
                billingMode = packageWithAllocation.billingMode
                cadence = packageWithAllocation.cadence
                compositePriceFilters =
                    packageWithAllocation.compositePriceFilters.map { it.toMutableList() }
                conversionRate = packageWithAllocation.conversionRate
                conversionRateConfig = packageWithAllocation.conversionRateConfig
                createdAt = packageWithAllocation.createdAt
                creditAllocation = packageWithAllocation.creditAllocation
                currency = packageWithAllocation.currency
                discount = packageWithAllocation.discount
                externalPriceId = packageWithAllocation.externalPriceId
                fixedPriceQuantity = packageWithAllocation.fixedPriceQuantity
                invoicingCycleConfiguration = packageWithAllocation.invoicingCycleConfiguration
                item = packageWithAllocation.item
                maximum = packageWithAllocation.maximum
                maximumAmount = packageWithAllocation.maximumAmount
                metadata = packageWithAllocation.metadata
                minimum = packageWithAllocation.minimum
                minimumAmount = packageWithAllocation.minimumAmount
                modelType = packageWithAllocation.modelType
                name = packageWithAllocation.name
                packageWithAllocationConfig = packageWithAllocation.packageWithAllocationConfig
                planPhaseOrder = packageWithAllocation.planPhaseOrder
                priceType = packageWithAllocation.priceType
                replacesPriceId = packageWithAllocation.replacesPriceId
                dimensionalPriceConfiguration = packageWithAllocation.dimensionalPriceConfiguration
                additionalProperties = packageWithAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("package_with_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /** Configuration for package_with_allocation pricing */
            fun packageWithAllocationConfig(
                packageWithAllocationConfig: PackageWithAllocationConfig
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            /**
             * Sets [Builder.packageWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageWithAllocationConfig] with a well-typed
             * [PackageWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [PackageWithAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): PackageWithAllocation =
                PackageWithAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): PackageWithAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("package_with_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            packageWithAllocationConfig().validate()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("package_with_allocation")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (packageWithAllocationConfig.asKnown()?.validity() ?: 0) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        /** Configuration for package_with_allocation pricing */
        class PackageWithAllocationConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val allocation: JsonField<String>,
            private val packageAmount: JsonField<String>,
            private val packageSize: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("allocation")
                @ExcludeMissing
                allocation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("package_amount")
                @ExcludeMissing
                packageAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("package_size")
                @ExcludeMissing
                packageSize: JsonField<String> = JsonMissing.of(),
            ) : this(allocation, packageAmount, packageSize, mutableMapOf())

            /**
             * Usage allocation
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allocation(): String = allocation.getRequired("allocation")

            /**
             * Price per package
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageAmount(): String = packageAmount.getRequired("package_amount")

            /**
             * Package size
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): String = packageSize.getRequired("package_size")

            /**
             * Returns the raw JSON value of [allocation].
             *
             * Unlike [allocation], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("allocation")
            @ExcludeMissing
            fun _allocation(): JsonField<String> = allocation

            /**
             * Returns the raw JSON value of [packageAmount].
             *
             * Unlike [packageAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_amount")
            @ExcludeMissing
            fun _packageAmount(): JsonField<String> = packageAmount

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<String> = packageSize

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [PackageWithAllocationConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .allocation()
                 * .packageAmount()
                 * .packageSize()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [PackageWithAllocationConfig]. */
            class Builder internal constructor() {

                private var allocation: JsonField<String>? = null
                private var packageAmount: JsonField<String>? = null
                private var packageSize: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                    apply {
                        allocation = packageWithAllocationConfig.allocation
                        packageAmount = packageWithAllocationConfig.packageAmount
                        packageSize = packageWithAllocationConfig.packageSize
                        additionalProperties =
                            packageWithAllocationConfig.additionalProperties.toMutableMap()
                    }

                /** Usage allocation */
                fun allocation(allocation: String) = allocation(JsonField.of(allocation))

                /**
                 * Sets [Builder.allocation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allocation] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun allocation(allocation: JsonField<String>) = apply {
                    this.allocation = allocation
                }

                /** Price per package */
                fun packageAmount(packageAmount: String) =
                    packageAmount(JsonField.of(packageAmount))

                /**
                 * Sets [Builder.packageAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageAmount(packageAmount: JsonField<String>) = apply {
                    this.packageAmount = packageAmount
                }

                /** Package size */
                fun packageSize(packageSize: String) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<String>) = apply {
                    this.packageSize = packageSize
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [PackageWithAllocationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .allocation()
                 * .packageAmount()
                 * .packageSize()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): PackageWithAllocationConfig =
                    PackageWithAllocationConfig(
                        checkRequired("allocation", allocation),
                        checkRequired("packageAmount", packageAmount),
                        checkRequired("packageSize", packageSize),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): PackageWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                allocation()
                packageAmount()
                packageSize()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (allocation.asKnown() == null) 0 else 1) +
                    (if (packageAmount.asKnown() == null) 0 else 1) +
                    (if (packageSize.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PackageWithAllocationConfig &&
                    allocation == other.allocation &&
                    packageAmount == other.packageAmount &&
                    packageSize == other.packageSize &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(allocation, packageAmount, packageSize, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageWithAllocationConfig{allocation=$allocation, packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is PackageWithAllocation &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                packageWithAllocationConfig == other.packageWithAllocationConfig &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                packageWithAllocationConfig,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackageWithAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class UnitWithPercent
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_with_percent_config")
            @ExcludeMissing
            unitWithPercentConfig: JsonField<UnitWithPercentConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitWithPercentConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("unit_with_percent")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for unit_with_percent pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithPercentConfig(): UnitWithPercentConfig =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitWithPercentConfig].
         *
         * Unlike [unitWithPercentConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<UnitWithPercentConfig> = unitWithPercentConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithPercent].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithPercentConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [UnitWithPercent]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit_with_percent")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitWithPercentConfig: JsonField<UnitWithPercentConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(unitWithPercent: UnitWithPercent) = apply {
                id = unitWithPercent.id
                billableMetric = unitWithPercent.billableMetric
                billingCycleConfiguration = unitWithPercent.billingCycleConfiguration
                billingMode = unitWithPercent.billingMode
                cadence = unitWithPercent.cadence
                compositePriceFilters =
                    unitWithPercent.compositePriceFilters.map { it.toMutableList() }
                conversionRate = unitWithPercent.conversionRate
                conversionRateConfig = unitWithPercent.conversionRateConfig
                createdAt = unitWithPercent.createdAt
                creditAllocation = unitWithPercent.creditAllocation
                currency = unitWithPercent.currency
                discount = unitWithPercent.discount
                externalPriceId = unitWithPercent.externalPriceId
                fixedPriceQuantity = unitWithPercent.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithPercent.invoicingCycleConfiguration
                item = unitWithPercent.item
                maximum = unitWithPercent.maximum
                maximumAmount = unitWithPercent.maximumAmount
                metadata = unitWithPercent.metadata
                minimum = unitWithPercent.minimum
                minimumAmount = unitWithPercent.minimumAmount
                modelType = unitWithPercent.modelType
                name = unitWithPercent.name
                planPhaseOrder = unitWithPercent.planPhaseOrder
                priceType = unitWithPercent.priceType
                replacesPriceId = unitWithPercent.replacesPriceId
                unitWithPercentConfig = unitWithPercent.unitWithPercentConfig
                dimensionalPriceConfiguration = unitWithPercent.dimensionalPriceConfiguration
                additionalProperties = unitWithPercent.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("unit_with_percent")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for unit_with_percent pricing */
            fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            /**
             * Sets [Builder.unitWithPercentConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithPercentConfig] with a well-typed
             * [UnitWithPercentConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                apply {
                    this.unitWithPercentConfig = unitWithPercentConfig
                }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [UnitWithPercent].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithPercentConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): UnitWithPercent =
                UnitWithPercent(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): UnitWithPercent = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit_with_percent")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitWithPercentConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("unit_with_percent")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (unitWithPercentConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for unit_with_percent pricing */
        class UnitWithPercentConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val percent: JsonField<String>,
            private val unitAmount: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("percent")
                @ExcludeMissing
                percent: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                unitAmount: JsonField<String> = JsonMissing.of(),
            ) : this(percent, unitAmount, mutableMapOf())

            /**
             * What percent, out of 100, of the calculated total to charge
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun percent(): String = percent.getRequired("percent")

            /**
             * Rate per unit of usage
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitAmount(): String = unitAmount.getRequired("unit_amount")

            /**
             * Returns the raw JSON value of [percent].
             *
             * Unlike [percent], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("percent") @ExcludeMissing fun _percent(): JsonField<String> = percent

            /**
             * Returns the raw JSON value of [unitAmount].
             *
             * Unlike [unitAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_amount")
            @ExcludeMissing
            fun _unitAmount(): JsonField<String> = unitAmount

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithPercentConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .percent()
                 * .unitAmount()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [UnitWithPercentConfig]. */
            class Builder internal constructor() {

                private var percent: JsonField<String>? = null
                private var unitAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                    percent = unitWithPercentConfig.percent
                    unitAmount = unitWithPercentConfig.unitAmount
                    additionalProperties = unitWithPercentConfig.additionalProperties.toMutableMap()
                }

                /** What percent, out of 100, of the calculated total to charge */
                fun percent(percent: String) = percent(JsonField.of(percent))

                /**
                 * Sets [Builder.percent] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.percent] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun percent(percent: JsonField<String>) = apply { this.percent = percent }

                /** Rate per unit of usage */
                fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                /**
                 * Sets [Builder.unitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitAmount(unitAmount: JsonField<String>) = apply {
                    this.unitAmount = unitAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UnitWithPercentConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .percent()
                 * .unitAmount()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): UnitWithPercentConfig =
                    UnitWithPercentConfig(
                        checkRequired("percent", percent),
                        checkRequired("unitAmount", unitAmount),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): UnitWithPercentConfig = apply {
                if (validated) {
                    return@apply
                }

                percent()
                unitAmount()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (percent.asKnown() == null) 0 else 1) +
                    (if (unitAmount.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is UnitWithPercentConfig &&
                    percent == other.percent &&
                    unitAmount == other.unitAmount &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(percent, unitAmount, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithPercentConfig{percent=$percent, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is UnitWithPercent &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                unitWithPercentConfig == other.unitWithPercentConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                unitWithPercentConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithPercent{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitWithPercentConfig=$unitWithPercentConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MatrixWithAllocation
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_with_allocation_config")
            @ExcludeMissing
            matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixWithAllocationConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * Configuration for matrix_with_allocation pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithAllocationConfig(): MatrixWithAllocationConfig =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("matrix_with_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixWithAllocationConfig].
         *
         * Unlike [matrixWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfig> =
            matrixWithAllocationConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixWithAllocation].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [MatrixWithAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix_with_allocation")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(matrixWithAllocation: MatrixWithAllocation) = apply {
                id = matrixWithAllocation.id
                billableMetric = matrixWithAllocation.billableMetric
                billingCycleConfiguration = matrixWithAllocation.billingCycleConfiguration
                billingMode = matrixWithAllocation.billingMode
                cadence = matrixWithAllocation.cadence
                compositePriceFilters =
                    matrixWithAllocation.compositePriceFilters.map { it.toMutableList() }
                conversionRate = matrixWithAllocation.conversionRate
                conversionRateConfig = matrixWithAllocation.conversionRateConfig
                createdAt = matrixWithAllocation.createdAt
                creditAllocation = matrixWithAllocation.creditAllocation
                currency = matrixWithAllocation.currency
                discount = matrixWithAllocation.discount
                externalPriceId = matrixWithAllocation.externalPriceId
                fixedPriceQuantity = matrixWithAllocation.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithAllocation.invoicingCycleConfiguration
                item = matrixWithAllocation.item
                matrixWithAllocationConfig = matrixWithAllocation.matrixWithAllocationConfig
                maximum = matrixWithAllocation.maximum
                maximumAmount = matrixWithAllocation.maximumAmount
                metadata = matrixWithAllocation.metadata
                minimum = matrixWithAllocation.minimum
                minimumAmount = matrixWithAllocation.minimumAmount
                modelType = matrixWithAllocation.modelType
                name = matrixWithAllocation.name
                planPhaseOrder = matrixWithAllocation.planPhaseOrder
                priceType = matrixWithAllocation.priceType
                replacesPriceId = matrixWithAllocation.replacesPriceId
                dimensionalPriceConfiguration = matrixWithAllocation.dimensionalPriceConfiguration
                additionalProperties = matrixWithAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            /** Configuration for matrix_with_allocation pricing */
            fun matrixWithAllocationConfig(matrixWithAllocationConfig: MatrixWithAllocationConfig) =
                matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            /**
             * Sets [Builder.matrixWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithAllocationConfig] with a well-typed
             * [MatrixWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("matrix_with_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MatrixWithAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MatrixWithAllocation =
                MatrixWithAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MatrixWithAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            matrixWithAllocationConfig().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix_with_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (matrixWithAllocationConfig.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("matrix_with_allocation")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is MatrixWithAllocation &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                matrixWithAllocationConfig == other.matrixWithAllocationConfig &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                matrixWithAllocationConfig,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithAllocationConfig=$matrixWithAllocationConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredWithProration
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_with_proration_config")
            @ExcludeMissing
            tieredWithProrationConfig: JsonField<TieredWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredWithProrationConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("tiered_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for tiered_with_proration pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithProrationConfig(): TieredWithProrationConfig =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredWithProrationConfig].
         *
         * Unlike [tieredWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<TieredWithProrationConfig> =
            tieredWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithProration].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithProrationConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [TieredWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(tieredWithProration: TieredWithProration) = apply {
                id = tieredWithProration.id
                billableMetric = tieredWithProration.billableMetric
                billingCycleConfiguration = tieredWithProration.billingCycleConfiguration
                billingMode = tieredWithProration.billingMode
                cadence = tieredWithProration.cadence
                compositePriceFilters =
                    tieredWithProration.compositePriceFilters.map { it.toMutableList() }
                conversionRate = tieredWithProration.conversionRate
                conversionRateConfig = tieredWithProration.conversionRateConfig
                createdAt = tieredWithProration.createdAt
                creditAllocation = tieredWithProration.creditAllocation
                currency = tieredWithProration.currency
                discount = tieredWithProration.discount
                externalPriceId = tieredWithProration.externalPriceId
                fixedPriceQuantity = tieredWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithProration.invoicingCycleConfiguration
                item = tieredWithProration.item
                maximum = tieredWithProration.maximum
                maximumAmount = tieredWithProration.maximumAmount
                metadata = tieredWithProration.metadata
                minimum = tieredWithProration.minimum
                minimumAmount = tieredWithProration.minimumAmount
                modelType = tieredWithProration.modelType
                name = tieredWithProration.name
                planPhaseOrder = tieredWithProration.planPhaseOrder
                priceType = tieredWithProration.priceType
                replacesPriceId = tieredWithProration.replacesPriceId
                tieredWithProrationConfig = tieredWithProration.tieredWithProrationConfig
                dimensionalPriceConfiguration = tieredWithProration.dimensionalPriceConfiguration
                additionalProperties = tieredWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("tiered_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for tiered_with_proration pricing */
            fun tieredWithProrationConfig(tieredWithProrationConfig: TieredWithProrationConfig) =
                tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            /**
             * Sets [Builder.tieredWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithProrationConfig] with a well-typed
             * [TieredWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithProrationConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredWithProration =
                TieredWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredWithProrationConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("tiered_with_proration")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (tieredWithProrationConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for tiered_with_proration pricing */
        class TieredWithProrationConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of()
            ) : this(tiers, mutableMapOf())

            /**
             * Tiers for rating based on total usage quantities into the specified tier with
             * proration
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithProrationConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [TieredWithProrationConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) = apply {
                    tiers = tieredWithProrationConfig.tiers.map { it.toMutableList() }
                    additionalProperties =
                        tieredWithProrationConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiers for rating based on total usage quantities into the specified tier with
                 * proration
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): TieredWithProrationConfig =
                    TieredWithProrationConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): TieredWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tiered with proration tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Inclusive tier starting value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Amount per unit
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        tierLowerBound = tier.tierLowerBound
                        unitAmount = tier.unitAmount
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Inclusive tier starting value */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is TieredWithProrationConfig &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithProrationConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is TieredWithProration &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                tieredWithProrationConfig == other.tieredWithProrationConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                tieredWithProrationConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredWithProrationConfig=$tieredWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class UnitWithProration
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_with_proration_config")
            @ExcludeMissing
            unitWithProrationConfig: JsonField<UnitWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitWithProrationConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("unit_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for unit_with_proration pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithProrationConfig(): UnitWithProrationConfig =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitWithProrationConfig].
         *
         * Unlike [unitWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<UnitWithProrationConfig> = unitWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithProration].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithProrationConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [UnitWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitWithProrationConfig: JsonField<UnitWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(unitWithProration: UnitWithProration) = apply {
                id = unitWithProration.id
                billableMetric = unitWithProration.billableMetric
                billingCycleConfiguration = unitWithProration.billingCycleConfiguration
                billingMode = unitWithProration.billingMode
                cadence = unitWithProration.cadence
                compositePriceFilters =
                    unitWithProration.compositePriceFilters.map { it.toMutableList() }
                conversionRate = unitWithProration.conversionRate
                conversionRateConfig = unitWithProration.conversionRateConfig
                createdAt = unitWithProration.createdAt
                creditAllocation = unitWithProration.creditAllocation
                currency = unitWithProration.currency
                discount = unitWithProration.discount
                externalPriceId = unitWithProration.externalPriceId
                fixedPriceQuantity = unitWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithProration.invoicingCycleConfiguration
                item = unitWithProration.item
                maximum = unitWithProration.maximum
                maximumAmount = unitWithProration.maximumAmount
                metadata = unitWithProration.metadata
                minimum = unitWithProration.minimum
                minimumAmount = unitWithProration.minimumAmount
                modelType = unitWithProration.modelType
                name = unitWithProration.name
                planPhaseOrder = unitWithProration.planPhaseOrder
                priceType = unitWithProration.priceType
                replacesPriceId = unitWithProration.replacesPriceId
                unitWithProrationConfig = unitWithProration.unitWithProrationConfig
                dimensionalPriceConfiguration = unitWithProration.dimensionalPriceConfiguration
                additionalProperties = unitWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("unit_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for unit_with_proration pricing */
            fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            /**
             * Sets [Builder.unitWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithProrationConfig] with a well-typed
             * [UnitWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<UnitWithProrationConfig>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [UnitWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithProrationConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): UnitWithProration =
                UnitWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): UnitWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitWithProrationConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("unit_with_proration")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (unitWithProrationConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for unit_with_proration pricing */
        class UnitWithProrationConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val unitAmount: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("unit_amount")
                @ExcludeMissing
                unitAmount: JsonField<String> = JsonMissing.of()
            ) : this(unitAmount, mutableMapOf())

            /**
             * Rate per unit of usage
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitAmount(): String = unitAmount.getRequired("unit_amount")

            /**
             * Returns the raw JSON value of [unitAmount].
             *
             * Unlike [unitAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_amount")
            @ExcludeMissing
            fun _unitAmount(): JsonField<String> = unitAmount

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithProrationConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .unitAmount()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [UnitWithProrationConfig]. */
            class Builder internal constructor() {

                private var unitAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                    unitAmount = unitWithProrationConfig.unitAmount
                    additionalProperties =
                        unitWithProrationConfig.additionalProperties.toMutableMap()
                }

                /** Rate per unit of usage */
                fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                /**
                 * Sets [Builder.unitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitAmount(unitAmount: JsonField<String>) = apply {
                    this.unitAmount = unitAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UnitWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .unitAmount()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): UnitWithProrationConfig =
                    UnitWithProrationConfig(
                        checkRequired("unitAmount", unitAmount),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): UnitWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                unitAmount()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (unitAmount.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is UnitWithProrationConfig &&
                    unitAmount == other.unitAmount &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(unitAmount, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithProrationConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is UnitWithProration &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                unitWithProrationConfig == other.unitWithProrationConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                unitWithProrationConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitWithProrationConfig=$unitWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedAllocation
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_allocation_config")
            @ExcludeMissing
            groupedAllocationConfig: JsonField<GroupedAllocationConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedAllocationConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_allocation pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedAllocationConfig(): GroupedAllocationConfig =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedAllocationConfig].
         *
         * Unlike [groupedAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<GroupedAllocationConfig> = groupedAllocationConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedAllocation].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedAllocationConfig: JsonField<GroupedAllocationConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_allocation")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedAllocation: GroupedAllocation) = apply {
                id = groupedAllocation.id
                billableMetric = groupedAllocation.billableMetric
                billingCycleConfiguration = groupedAllocation.billingCycleConfiguration
                billingMode = groupedAllocation.billingMode
                cadence = groupedAllocation.cadence
                compositePriceFilters =
                    groupedAllocation.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedAllocation.conversionRate
                conversionRateConfig = groupedAllocation.conversionRateConfig
                createdAt = groupedAllocation.createdAt
                creditAllocation = groupedAllocation.creditAllocation
                currency = groupedAllocation.currency
                discount = groupedAllocation.discount
                externalPriceId = groupedAllocation.externalPriceId
                fixedPriceQuantity = groupedAllocation.fixedPriceQuantity
                groupedAllocationConfig = groupedAllocation.groupedAllocationConfig
                invoicingCycleConfiguration = groupedAllocation.invoicingCycleConfiguration
                item = groupedAllocation.item
                maximum = groupedAllocation.maximum
                maximumAmount = groupedAllocation.maximumAmount
                metadata = groupedAllocation.metadata
                minimum = groupedAllocation.minimum
                minimumAmount = groupedAllocation.minimumAmount
                modelType = groupedAllocation.modelType
                name = groupedAllocation.name
                planPhaseOrder = groupedAllocation.planPhaseOrder
                priceType = groupedAllocation.priceType
                replacesPriceId = groupedAllocation.replacesPriceId
                dimensionalPriceConfiguration = groupedAllocation.dimensionalPriceConfiguration
                additionalProperties = groupedAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_allocation pricing */
            fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            /**
             * Sets [Builder.groupedAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedAllocationConfig] with a well-typed
             * [GroupedAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<GroupedAllocationConfig>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedAllocation =
                GroupedAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedAllocationConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedAllocationConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("grouped_allocation")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_allocation pricing */
        class GroupedAllocationConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val allocation: JsonField<String>,
            private val groupingKey: JsonField<String>,
            private val overageUnitRate: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("allocation")
                @ExcludeMissing
                allocation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("overage_unit_rate")
                @ExcludeMissing
                overageUnitRate: JsonField<String> = JsonMissing.of(),
            ) : this(allocation, groupingKey, overageUnitRate, mutableMapOf())

            /**
             * Usage allocation per group
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allocation(): String = allocation.getRequired("allocation")

            /**
             * How to determine the groups that should each be allocated some quantity
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * Unit rate for post-allocation
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun overageUnitRate(): String = overageUnitRate.getRequired("overage_unit_rate")

            /**
             * Returns the raw JSON value of [allocation].
             *
             * Unlike [allocation], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("allocation")
            @ExcludeMissing
            fun _allocation(): JsonField<String> = allocation

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [overageUnitRate].
             *
             * Unlike [overageUnitRate], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("overage_unit_rate")
            @ExcludeMissing
            fun _overageUnitRate(): JsonField<String> = overageUnitRate

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedAllocationConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .allocation()
                 * .groupingKey()
                 * .overageUnitRate()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedAllocationConfig]. */
            class Builder internal constructor() {

                private var allocation: JsonField<String>? = null
                private var groupingKey: JsonField<String>? = null
                private var overageUnitRate: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                    allocation = groupedAllocationConfig.allocation
                    groupingKey = groupedAllocationConfig.groupingKey
                    overageUnitRate = groupedAllocationConfig.overageUnitRate
                    additionalProperties =
                        groupedAllocationConfig.additionalProperties.toMutableMap()
                }

                /** Usage allocation per group */
                fun allocation(allocation: String) = allocation(JsonField.of(allocation))

                /**
                 * Sets [Builder.allocation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allocation] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun allocation(allocation: JsonField<String>) = apply {
                    this.allocation = allocation
                }

                /** How to determine the groups that should each be allocated some quantity */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** Unit rate for post-allocation */
                fun overageUnitRate(overageUnitRate: String) =
                    overageUnitRate(JsonField.of(overageUnitRate))

                /**
                 * Sets [Builder.overageUnitRate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.overageUnitRate] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun overageUnitRate(overageUnitRate: JsonField<String>) = apply {
                    this.overageUnitRate = overageUnitRate
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedAllocationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .allocation()
                 * .groupingKey()
                 * .overageUnitRate()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedAllocationConfig =
                    GroupedAllocationConfig(
                        checkRequired("allocation", allocation),
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("overageUnitRate", overageUnitRate),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                allocation()
                groupingKey()
                overageUnitRate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (allocation.asKnown() == null) 0 else 1) +
                    (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (overageUnitRate.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedAllocationConfig &&
                    allocation == other.allocation &&
                    groupingKey == other.groupingKey &&
                    overageUnitRate == other.overageUnitRate &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(allocation, groupingKey, overageUnitRate, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedAllocationConfig{allocation=$allocation, groupingKey=$groupingKey, overageUnitRate=$overageUnitRate, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedAllocation &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedAllocationConfig == other.groupedAllocationConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedAllocationConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class BulkWithProration
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("bulk_with_proration_config")
            @ExcludeMissing
            bulkWithProrationConfig: JsonField<BulkWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            bulkWithProrationConfig,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * Configuration for bulk_with_proration pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkWithProrationConfig(): BulkWithProrationConfig =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("bulk_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [bulkWithProrationConfig].
         *
         * Unlike [bulkWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<BulkWithProrationConfig> = bulkWithProrationConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkWithProration].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkWithProrationConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [BulkWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(bulkWithProration: BulkWithProration) = apply {
                id = bulkWithProration.id
                billableMetric = bulkWithProration.billableMetric
                billingCycleConfiguration = bulkWithProration.billingCycleConfiguration
                billingMode = bulkWithProration.billingMode
                bulkWithProrationConfig = bulkWithProration.bulkWithProrationConfig
                cadence = bulkWithProration.cadence
                compositePriceFilters =
                    bulkWithProration.compositePriceFilters.map { it.toMutableList() }
                conversionRate = bulkWithProration.conversionRate
                conversionRateConfig = bulkWithProration.conversionRateConfig
                createdAt = bulkWithProration.createdAt
                creditAllocation = bulkWithProration.creditAllocation
                currency = bulkWithProration.currency
                discount = bulkWithProration.discount
                externalPriceId = bulkWithProration.externalPriceId
                fixedPriceQuantity = bulkWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithProration.invoicingCycleConfiguration
                item = bulkWithProration.item
                maximum = bulkWithProration.maximum
                maximumAmount = bulkWithProration.maximumAmount
                metadata = bulkWithProration.metadata
                minimum = bulkWithProration.minimum
                minimumAmount = bulkWithProration.minimumAmount
                modelType = bulkWithProration.modelType
                name = bulkWithProration.name
                planPhaseOrder = bulkWithProration.planPhaseOrder
                priceType = bulkWithProration.priceType
                replacesPriceId = bulkWithProration.replacesPriceId
                dimensionalPriceConfiguration = bulkWithProration.dimensionalPriceConfiguration
                additionalProperties = bulkWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            /** Configuration for bulk_with_proration pricing */
            fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            /**
             * Sets [Builder.bulkWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkWithProrationConfig] with a well-typed
             * [BulkWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("bulk_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [BulkWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .bulkWithProrationConfig()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): BulkWithProration =
                BulkWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): BulkWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            bulkWithProrationConfig().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (bulkWithProrationConfig.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("bulk_with_proration")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for bulk_with_proration pricing */
        class BulkWithProrationConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of()
            ) : this(tiers, mutableMapOf())

            /**
             * Bulk tiers for rating based on total usage volume
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BulkWithProrationConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [BulkWithProrationConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                    tiers = bulkWithProrationConfig.tiers.map { it.toMutableList() }
                    additionalProperties =
                        bulkWithProrationConfig.additionalProperties.toMutableMap()
                }

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [BulkWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): BulkWithProrationConfig =
                    BulkWithProrationConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): BulkWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single bulk pricing tier with proration */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val unitAmount: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                ) : this(unitAmount, tierLowerBound, mutableMapOf())

                /**
                 * Cost per unit
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * The lower bound for this tier
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun tierLowerBound(): String? = tierLowerBound.getNullable("tier_lower_bound")

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var unitAmount: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        unitAmount = tier.unitAmount
                        tierLowerBound = tier.tierLowerBound
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Cost per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** The lower bound for this tier */
                    fun tierLowerBound(tierLowerBound: String?) =
                        tierLowerBound(JsonField.ofNullable(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("unitAmount", unitAmount),
                            tierLowerBound,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    unitAmount()
                    tierLowerBound()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (unitAmount.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        unitAmount == other.unitAmount &&
                        tierLowerBound == other.tierLowerBound &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(unitAmount, tierLowerBound, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{unitAmount=$unitAmount, tierLowerBound=$tierLowerBound, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BulkWithProrationConfig &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkWithProrationConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is BulkWithProration &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                bulkWithProrationConfig == other.bulkWithProrationConfig &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                bulkWithProrationConfig,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithProratedMinimum
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_prorated_minimum_config")
            @ExcludeMissing
            groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithProratedMinimumConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_with_prorated_minimum pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_with_prorated_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithProratedMinimumConfig].
         *
         * Unlike [groupedWithProratedMinimumConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<GroupedWithProratedMinimumConfig> =
            groupedWithProratedMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithProratedMinimum].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedWithProratedMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_prorated_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedWithProratedMinimum: GroupedWithProratedMinimum) = apply {
                id = groupedWithProratedMinimum.id
                billableMetric = groupedWithProratedMinimum.billableMetric
                billingCycleConfiguration = groupedWithProratedMinimum.billingCycleConfiguration
                billingMode = groupedWithProratedMinimum.billingMode
                cadence = groupedWithProratedMinimum.cadence
                compositePriceFilters =
                    groupedWithProratedMinimum.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedWithProratedMinimum.conversionRate
                conversionRateConfig = groupedWithProratedMinimum.conversionRateConfig
                createdAt = groupedWithProratedMinimum.createdAt
                creditAllocation = groupedWithProratedMinimum.creditAllocation
                currency = groupedWithProratedMinimum.currency
                discount = groupedWithProratedMinimum.discount
                externalPriceId = groupedWithProratedMinimum.externalPriceId
                fixedPriceQuantity = groupedWithProratedMinimum.fixedPriceQuantity
                groupedWithProratedMinimumConfig =
                    groupedWithProratedMinimum.groupedWithProratedMinimumConfig
                invoicingCycleConfiguration = groupedWithProratedMinimum.invoicingCycleConfiguration
                item = groupedWithProratedMinimum.item
                maximum = groupedWithProratedMinimum.maximum
                maximumAmount = groupedWithProratedMinimum.maximumAmount
                metadata = groupedWithProratedMinimum.metadata
                minimum = groupedWithProratedMinimum.minimum
                minimumAmount = groupedWithProratedMinimum.minimumAmount
                modelType = groupedWithProratedMinimum.modelType
                name = groupedWithProratedMinimum.name
                planPhaseOrder = groupedWithProratedMinimum.planPhaseOrder
                priceType = groupedWithProratedMinimum.priceType
                replacesPriceId = groupedWithProratedMinimum.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithProratedMinimum.dimensionalPriceConfiguration
                additionalProperties =
                    groupedWithProratedMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_with_prorated_minimum pricing */
            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            /**
             * Sets [Builder.groupedWithProratedMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithProratedMinimumConfig] with a well-typed
             * [GroupedWithProratedMinimumConfig] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_with_prorated_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithProratedMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithProratedMinimum =
                GroupedWithProratedMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithProratedMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedWithProratedMinimumConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_prorated_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedWithProratedMinimumConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_prorated_minimum")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_with_prorated_minimum pricing */
        class GroupedWithProratedMinimumConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val minimum: JsonField<String>,
            private val unitRate: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("minimum")
                @ExcludeMissing
                minimum: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unit_rate")
                @ExcludeMissing
                unitRate: JsonField<String> = JsonMissing.of(),
            ) : this(groupingKey, minimum, unitRate, mutableMapOf())

            /**
             * How to determine the groups that should each have a minimum
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * The minimum amount to charge per group
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimum(): String = minimum.getRequired("minimum")

            /**
             * The amount to charge per unit
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitRate(): String = unitRate.getRequired("unit_rate")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [minimum].
             *
             * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<String> = minimum

            /**
             * Returns the raw JSON value of [unitRate].
             *
             * Unlike [unitRate], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_rate") @ExcludeMissing fun _unitRate(): JsonField<String> = unitRate

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithProratedMinimumConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .minimum()
                 * .unitRate()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedWithProratedMinimumConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var minimum: JsonField<String>? = null
                private var unitRate: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = apply {
                    groupingKey = groupedWithProratedMinimumConfig.groupingKey
                    minimum = groupedWithProratedMinimumConfig.minimum
                    unitRate = groupedWithProratedMinimumConfig.unitRate
                    additionalProperties =
                        groupedWithProratedMinimumConfig.additionalProperties.toMutableMap()
                }

                /** How to determine the groups that should each have a minimum */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** The minimum amount to charge per group */
                fun minimum(minimum: String) = minimum(JsonField.of(minimum))

                /**
                 * Sets [Builder.minimum] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimum] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimum(minimum: JsonField<String>) = apply { this.minimum = minimum }

                /** The amount to charge per unit */
                fun unitRate(unitRate: String) = unitRate(JsonField.of(unitRate))

                /**
                 * Sets [Builder.unitRate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitRate] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitRate(unitRate: JsonField<String>) = apply { this.unitRate = unitRate }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithProratedMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .minimum()
                 * .unitRate()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedWithProratedMinimumConfig =
                    GroupedWithProratedMinimumConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("minimum", minimum),
                        checkRequired("unitRate", unitRate),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithProratedMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                minimum()
                unitRate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (minimum.asKnown() == null) 0 else 1) +
                    (if (unitRate.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedWithProratedMinimumConfig &&
                    groupingKey == other.groupingKey &&
                    minimum == other.minimum &&
                    unitRate == other.unitRate &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(groupingKey, minimum, unitRate, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithProratedMinimumConfig{groupingKey=$groupingKey, minimum=$minimum, unitRate=$unitRate, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedWithProratedMinimum &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedWithProratedMinimumConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithProratedMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithMeteredMinimum
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_metered_minimum_config")
            @ExcludeMissing
            groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithMeteredMinimumConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_with_metered_minimum pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_with_metered_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithMeteredMinimumConfig].
         *
         * Unlike [groupedWithMeteredMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<GroupedWithMeteredMinimumConfig> =
            groupedWithMeteredMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMeteredMinimum].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedWithMeteredMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<GroupedWithMeteredMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_metered_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedWithMeteredMinimum: GroupedWithMeteredMinimum) = apply {
                id = groupedWithMeteredMinimum.id
                billableMetric = groupedWithMeteredMinimum.billableMetric
                billingCycleConfiguration = groupedWithMeteredMinimum.billingCycleConfiguration
                billingMode = groupedWithMeteredMinimum.billingMode
                cadence = groupedWithMeteredMinimum.cadence
                compositePriceFilters =
                    groupedWithMeteredMinimum.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedWithMeteredMinimum.conversionRate
                conversionRateConfig = groupedWithMeteredMinimum.conversionRateConfig
                createdAt = groupedWithMeteredMinimum.createdAt
                creditAllocation = groupedWithMeteredMinimum.creditAllocation
                currency = groupedWithMeteredMinimum.currency
                discount = groupedWithMeteredMinimum.discount
                externalPriceId = groupedWithMeteredMinimum.externalPriceId
                fixedPriceQuantity = groupedWithMeteredMinimum.fixedPriceQuantity
                groupedWithMeteredMinimumConfig =
                    groupedWithMeteredMinimum.groupedWithMeteredMinimumConfig
                invoicingCycleConfiguration = groupedWithMeteredMinimum.invoicingCycleConfiguration
                item = groupedWithMeteredMinimum.item
                maximum = groupedWithMeteredMinimum.maximum
                maximumAmount = groupedWithMeteredMinimum.maximumAmount
                metadata = groupedWithMeteredMinimum.metadata
                minimum = groupedWithMeteredMinimum.minimum
                minimumAmount = groupedWithMeteredMinimum.minimumAmount
                modelType = groupedWithMeteredMinimum.modelType
                name = groupedWithMeteredMinimum.name
                planPhaseOrder = groupedWithMeteredMinimum.planPhaseOrder
                priceType = groupedWithMeteredMinimum.priceType
                replacesPriceId = groupedWithMeteredMinimum.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithMeteredMinimum.dimensionalPriceConfiguration
                additionalProperties = groupedWithMeteredMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_with_metered_minimum pricing */
            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            /**
             * Sets [Builder.groupedWithMeteredMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithMeteredMinimumConfig] with a well-typed
             * [GroupedWithMeteredMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_with_metered_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithMeteredMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithMeteredMinimum =
                GroupedWithMeteredMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithMeteredMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMeteredMinimumConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_metered_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedWithMeteredMinimumConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_metered_minimum")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_with_metered_minimum pricing */
        class GroupedWithMeteredMinimumConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val minimumUnitAmount: JsonField<String>,
            private val pricingKey: JsonField<String>,
            private val scalingFactors: JsonField<List<ScalingFactor>>,
            private val scalingKey: JsonField<String>,
            private val unitAmounts: JsonField<List<UnitAmount>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("minimum_unit_amount")
                @ExcludeMissing
                minimumUnitAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("pricing_key")
                @ExcludeMissing
                pricingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("scaling_factors")
                @ExcludeMissing
                scalingFactors: JsonField<List<ScalingFactor>> = JsonMissing.of(),
                @JsonProperty("scaling_key")
                @ExcludeMissing
                scalingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unit_amounts")
                @ExcludeMissing
                unitAmounts: JsonField<List<UnitAmount>> = JsonMissing.of(),
            ) : this(
                groupingKey,
                minimumUnitAmount,
                pricingKey,
                scalingFactors,
                scalingKey,
                unitAmounts,
                mutableMapOf(),
            )

            /**
             * Used to partition the usage into groups. The minimum amount is applied to each group.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * The minimum amount to charge per group per unit
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumUnitAmount(): String = minimumUnitAmount.getRequired("minimum_unit_amount")

            /**
             * Used to determine the unit rate
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun pricingKey(): String = pricingKey.getRequired("pricing_key")

            /**
             * Scale the unit rates by the scaling factor.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun scalingFactors(): List<ScalingFactor> =
                scalingFactors.getRequired("scaling_factors")

            /**
             * Used to determine the unit rate scaling factor
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun scalingKey(): String = scalingKey.getRequired("scaling_key")

            /**
             * Apply per unit pricing to each pricing value. The minimum amount is applied any
             * unmatched usage.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitAmounts(): List<UnitAmount> = unitAmounts.getRequired("unit_amounts")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [minimumUnitAmount].
             *
             * Unlike [minimumUnitAmount], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("minimum_unit_amount")
            @ExcludeMissing
            fun _minimumUnitAmount(): JsonField<String> = minimumUnitAmount

            /**
             * Returns the raw JSON value of [pricingKey].
             *
             * Unlike [pricingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("pricing_key")
            @ExcludeMissing
            fun _pricingKey(): JsonField<String> = pricingKey

            /**
             * Returns the raw JSON value of [scalingFactors].
             *
             * Unlike [scalingFactors], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("scaling_factors")
            @ExcludeMissing
            fun _scalingFactors(): JsonField<List<ScalingFactor>> = scalingFactors

            /**
             * Returns the raw JSON value of [scalingKey].
             *
             * Unlike [scalingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("scaling_key")
            @ExcludeMissing
            fun _scalingKey(): JsonField<String> = scalingKey

            /**
             * Returns the raw JSON value of [unitAmounts].
             *
             * Unlike [unitAmounts], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_amounts")
            @ExcludeMissing
            fun _unitAmounts(): JsonField<List<UnitAmount>> = unitAmounts

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithMeteredMinimumConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .minimumUnitAmount()
                 * .pricingKey()
                 * .scalingFactors()
                 * .scalingKey()
                 * .unitAmounts()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedWithMeteredMinimumConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var minimumUnitAmount: JsonField<String>? = null
                private var pricingKey: JsonField<String>? = null
                private var scalingFactors: JsonField<MutableList<ScalingFactor>>? = null
                private var scalingKey: JsonField<String>? = null
                private var unitAmounts: JsonField<MutableList<UnitAmount>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = apply {
                    groupingKey = groupedWithMeteredMinimumConfig.groupingKey
                    minimumUnitAmount = groupedWithMeteredMinimumConfig.minimumUnitAmount
                    pricingKey = groupedWithMeteredMinimumConfig.pricingKey
                    scalingFactors =
                        groupedWithMeteredMinimumConfig.scalingFactors.map { it.toMutableList() }
                    scalingKey = groupedWithMeteredMinimumConfig.scalingKey
                    unitAmounts =
                        groupedWithMeteredMinimumConfig.unitAmounts.map { it.toMutableList() }
                    additionalProperties =
                        groupedWithMeteredMinimumConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Used to partition the usage into groups. The minimum amount is applied to each
                 * group.
                 */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** The minimum amount to charge per group per unit */
                fun minimumUnitAmount(minimumUnitAmount: String) =
                    minimumUnitAmount(JsonField.of(minimumUnitAmount))

                /**
                 * Sets [Builder.minimumUnitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumUnitAmount] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun minimumUnitAmount(minimumUnitAmount: JsonField<String>) = apply {
                    this.minimumUnitAmount = minimumUnitAmount
                }

                /** Used to determine the unit rate */
                fun pricingKey(pricingKey: String) = pricingKey(JsonField.of(pricingKey))

                /**
                 * Sets [Builder.pricingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.pricingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun pricingKey(pricingKey: JsonField<String>) = apply {
                    this.pricingKey = pricingKey
                }

                /** Scale the unit rates by the scaling factor. */
                fun scalingFactors(scalingFactors: List<ScalingFactor>) =
                    scalingFactors(JsonField.of(scalingFactors))

                /**
                 * Sets [Builder.scalingFactors] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.scalingFactors] with a well-typed
                 * `List<ScalingFactor>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun scalingFactors(scalingFactors: JsonField<List<ScalingFactor>>) = apply {
                    this.scalingFactors = scalingFactors.map { it.toMutableList() }
                }

                /**
                 * Adds a single [ScalingFactor] to [scalingFactors].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addScalingFactor(scalingFactor: ScalingFactor) = apply {
                    scalingFactors =
                        (scalingFactors ?: JsonField.of(mutableListOf())).also {
                            checkKnown("scalingFactors", it).add(scalingFactor)
                        }
                }

                /** Used to determine the unit rate scaling factor */
                fun scalingKey(scalingKey: String) = scalingKey(JsonField.of(scalingKey))

                /**
                 * Sets [Builder.scalingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.scalingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun scalingKey(scalingKey: JsonField<String>) = apply {
                    this.scalingKey = scalingKey
                }

                /**
                 * Apply per unit pricing to each pricing value. The minimum amount is applied any
                 * unmatched usage.
                 */
                fun unitAmounts(unitAmounts: List<UnitAmount>) =
                    unitAmounts(JsonField.of(unitAmounts))

                /**
                 * Sets [Builder.unitAmounts] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitAmounts] with a well-typed
                 * `List<UnitAmount>` value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun unitAmounts(unitAmounts: JsonField<List<UnitAmount>>) = apply {
                    this.unitAmounts = unitAmounts.map { it.toMutableList() }
                }

                /**
                 * Adds a single [UnitAmount] to [unitAmounts].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addUnitAmount(unitAmount: UnitAmount) = apply {
                    unitAmounts =
                        (unitAmounts ?: JsonField.of(mutableListOf())).also {
                            checkKnown("unitAmounts", it).add(unitAmount)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithMeteredMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .minimumUnitAmount()
                 * .pricingKey()
                 * .scalingFactors()
                 * .scalingKey()
                 * .unitAmounts()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedWithMeteredMinimumConfig =
                    GroupedWithMeteredMinimumConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("minimumUnitAmount", minimumUnitAmount),
                        checkRequired("pricingKey", pricingKey),
                        checkRequired("scalingFactors", scalingFactors).map { it.toImmutable() },
                        checkRequired("scalingKey", scalingKey),
                        checkRequired("unitAmounts", unitAmounts).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithMeteredMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                minimumUnitAmount()
                pricingKey()
                scalingFactors().forEach { it.validate() }
                scalingKey()
                unitAmounts().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (minimumUnitAmount.asKnown() == null) 0 else 1) +
                    (if (pricingKey.asKnown() == null) 0 else 1) +
                    (scalingFactors.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (scalingKey.asKnown() == null) 0 else 1) +
                    (unitAmounts.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a scaling factor */
            class ScalingFactor
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val scalingFactor: JsonField<String>,
                private val scalingValue: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("scaling_factor")
                    @ExcludeMissing
                    scalingFactor: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("scaling_value")
                    @ExcludeMissing
                    scalingValue: JsonField<String> = JsonMissing.of(),
                ) : this(scalingFactor, scalingValue, mutableMapOf())

                /**
                 * Scaling factor
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun scalingFactor(): String = scalingFactor.getRequired("scaling_factor")

                /**
                 * Scaling value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun scalingValue(): String = scalingValue.getRequired("scaling_value")

                /**
                 * Returns the raw JSON value of [scalingFactor].
                 *
                 * Unlike [scalingFactor], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("scaling_factor")
                @ExcludeMissing
                fun _scalingFactor(): JsonField<String> = scalingFactor

                /**
                 * Returns the raw JSON value of [scalingValue].
                 *
                 * Unlike [scalingValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("scaling_value")
                @ExcludeMissing
                fun _scalingValue(): JsonField<String> = scalingValue

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [ScalingFactor].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .scalingFactor()
                     * .scalingValue()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ScalingFactor]. */
                class Builder internal constructor() {

                    private var scalingFactor: JsonField<String>? = null
                    private var scalingValue: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(scalingFactor: ScalingFactor) = apply {
                        this.scalingFactor = scalingFactor.scalingFactor
                        scalingValue = scalingFactor.scalingValue
                        additionalProperties = scalingFactor.additionalProperties.toMutableMap()
                    }

                    /** Scaling factor */
                    fun scalingFactor(scalingFactor: String) =
                        scalingFactor(JsonField.of(scalingFactor))

                    /**
                     * Sets [Builder.scalingFactor] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.scalingFactor] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun scalingFactor(scalingFactor: JsonField<String>) = apply {
                        this.scalingFactor = scalingFactor
                    }

                    /** Scaling value */
                    fun scalingValue(scalingValue: String) =
                        scalingValue(JsonField.of(scalingValue))

                    /**
                     * Sets [Builder.scalingValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.scalingValue] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun scalingValue(scalingValue: JsonField<String>) = apply {
                        this.scalingValue = scalingValue
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ScalingFactor].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .scalingFactor()
                     * .scalingValue()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ScalingFactor =
                        ScalingFactor(
                            checkRequired("scalingFactor", scalingFactor),
                            checkRequired("scalingValue", scalingValue),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ScalingFactor = apply {
                    if (validated) {
                        return@apply
                    }

                    scalingFactor()
                    scalingValue()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (scalingFactor.asKnown() == null) 0 else 1) +
                        (if (scalingValue.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ScalingFactor &&
                        scalingFactor == other.scalingFactor &&
                        scalingValue == other.scalingValue &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(scalingFactor, scalingValue, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ScalingFactor{scalingFactor=$scalingFactor, scalingValue=$scalingValue, additionalProperties=$additionalProperties}"
            }

            /** Configuration for a unit amount */
            class UnitAmount
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val pricingValue: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("pricing_value")
                    @ExcludeMissing
                    pricingValue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(pricingValue, unitAmount, mutableMapOf())

                /**
                 * Pricing value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun pricingValue(): String = pricingValue.getRequired("pricing_value")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [pricingValue].
                 *
                 * Unlike [pricingValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("pricing_value")
                @ExcludeMissing
                fun _pricingValue(): JsonField<String> = pricingValue

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [UnitAmount].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .pricingValue()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [UnitAmount]. */
                class Builder internal constructor() {

                    private var pricingValue: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(unitAmount: UnitAmount) = apply {
                        pricingValue = unitAmount.pricingValue
                        this.unitAmount = unitAmount.unitAmount
                        additionalProperties = unitAmount.additionalProperties.toMutableMap()
                    }

                    /** Pricing value */
                    fun pricingValue(pricingValue: String) =
                        pricingValue(JsonField.of(pricingValue))

                    /**
                     * Sets [Builder.pricingValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.pricingValue] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun pricingValue(pricingValue: JsonField<String>) = apply {
                        this.pricingValue = pricingValue
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [UnitAmount].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .pricingValue()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): UnitAmount =
                        UnitAmount(
                            checkRequired("pricingValue", pricingValue),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): UnitAmount = apply {
                    if (validated) {
                        return@apply
                    }

                    pricingValue()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (pricingValue.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitAmount &&
                        pricingValue == other.pricingValue &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(pricingValue, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UnitAmount{pricingValue=$pricingValue, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedWithMeteredMinimumConfig &&
                    groupingKey == other.groupingKey &&
                    minimumUnitAmount == other.minimumUnitAmount &&
                    pricingKey == other.pricingKey &&
                    scalingFactors == other.scalingFactors &&
                    scalingKey == other.scalingKey &&
                    unitAmounts == other.unitAmounts &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    groupingKey,
                    minimumUnitAmount,
                    pricingKey,
                    scalingFactors,
                    scalingKey,
                    unitAmounts,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMeteredMinimumConfig{groupingKey=$groupingKey, minimumUnitAmount=$minimumUnitAmount, pricingKey=$pricingKey, scalingFactors=$scalingFactors, scalingKey=$scalingKey, unitAmounts=$unitAmounts, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedWithMeteredMinimum &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedWithMeteredMinimumConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMeteredMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithMinMaxThresholds
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_min_max_thresholds_config")
            @ExcludeMissing
            groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithMinMaxThresholdsConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_with_min_max_thresholds pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithMinMaxThresholdsConfig(): GroupedWithMinMaxThresholdsConfig =
            groupedWithMinMaxThresholdsConfig.getRequired("grouped_with_min_max_thresholds_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_with_min_max_thresholds")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithMinMaxThresholdsConfig].
         *
         * Unlike [groupedWithMinMaxThresholdsConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("grouped_with_min_max_thresholds_config")
        @ExcludeMissing
        fun _groupedWithMinMaxThresholdsConfig(): JsonField<GroupedWithMinMaxThresholdsConfig> =
            groupedWithMinMaxThresholdsConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMinMaxThresholds].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMinMaxThresholdsConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedWithMinMaxThresholds]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMinMaxThresholdsConfig:
                JsonField<GroupedWithMinMaxThresholdsConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_min_max_thresholds")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds) = apply {
                id = groupedWithMinMaxThresholds.id
                billableMetric = groupedWithMinMaxThresholds.billableMetric
                billingCycleConfiguration = groupedWithMinMaxThresholds.billingCycleConfiguration
                billingMode = groupedWithMinMaxThresholds.billingMode
                cadence = groupedWithMinMaxThresholds.cadence
                compositePriceFilters =
                    groupedWithMinMaxThresholds.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedWithMinMaxThresholds.conversionRate
                conversionRateConfig = groupedWithMinMaxThresholds.conversionRateConfig
                createdAt = groupedWithMinMaxThresholds.createdAt
                creditAllocation = groupedWithMinMaxThresholds.creditAllocation
                currency = groupedWithMinMaxThresholds.currency
                discount = groupedWithMinMaxThresholds.discount
                externalPriceId = groupedWithMinMaxThresholds.externalPriceId
                fixedPriceQuantity = groupedWithMinMaxThresholds.fixedPriceQuantity
                groupedWithMinMaxThresholdsConfig =
                    groupedWithMinMaxThresholds.groupedWithMinMaxThresholdsConfig
                invoicingCycleConfiguration =
                    groupedWithMinMaxThresholds.invoicingCycleConfiguration
                item = groupedWithMinMaxThresholds.item
                maximum = groupedWithMinMaxThresholds.maximum
                maximumAmount = groupedWithMinMaxThresholds.maximumAmount
                metadata = groupedWithMinMaxThresholds.metadata
                minimum = groupedWithMinMaxThresholds.minimum
                minimumAmount = groupedWithMinMaxThresholds.minimumAmount
                modelType = groupedWithMinMaxThresholds.modelType
                name = groupedWithMinMaxThresholds.name
                planPhaseOrder = groupedWithMinMaxThresholds.planPhaseOrder
                priceType = groupedWithMinMaxThresholds.priceType
                replacesPriceId = groupedWithMinMaxThresholds.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithMinMaxThresholds.dimensionalPriceConfiguration
                additionalProperties =
                    groupedWithMinMaxThresholds.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_with_min_max_thresholds pricing */
            fun groupedWithMinMaxThresholdsConfig(
                groupedWithMinMaxThresholdsConfig: GroupedWithMinMaxThresholdsConfig
            ) = groupedWithMinMaxThresholdsConfig(JsonField.of(groupedWithMinMaxThresholdsConfig))

            /**
             * Sets [Builder.groupedWithMinMaxThresholdsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithMinMaxThresholdsConfig] with a well-typed
             * [GroupedWithMinMaxThresholdsConfig] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun groupedWithMinMaxThresholdsConfig(
                groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig>
            ) = apply { this.groupedWithMinMaxThresholdsConfig = groupedWithMinMaxThresholdsConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_with_min_max_thresholds")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithMinMaxThresholds].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMinMaxThresholdsConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithMinMaxThresholds =
                GroupedWithMinMaxThresholds(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMinMaxThresholdsConfig",
                        groupedWithMinMaxThresholdsConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithMinMaxThresholds = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMinMaxThresholdsConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_min_max_thresholds")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedWithMinMaxThresholdsConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_min_max_thresholds")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_with_min_max_thresholds pricing */
        class GroupedWithMinMaxThresholdsConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val maximumCharge: JsonField<String>,
            private val minimumCharge: JsonField<String>,
            private val perUnitRate: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("maximum_charge")
                @ExcludeMissing
                maximumCharge: JsonField<String> = JsonMissing.of(),
                @JsonProperty("minimum_charge")
                @ExcludeMissing
                minimumCharge: JsonField<String> = JsonMissing.of(),
                @JsonProperty("per_unit_rate")
                @ExcludeMissing
                perUnitRate: JsonField<String> = JsonMissing.of(),
            ) : this(groupingKey, maximumCharge, minimumCharge, perUnitRate, mutableMapOf())

            /**
             * The event property used to group before applying thresholds
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * The maximum amount to charge each group
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumCharge(): String = maximumCharge.getRequired("maximum_charge")

            /**
             * The minimum amount to charge each group, regardless of usage
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumCharge(): String = minimumCharge.getRequired("minimum_charge")

            /**
             * The base price charged per group
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun perUnitRate(): String = perUnitRate.getRequired("per_unit_rate")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [maximumCharge].
             *
             * Unlike [maximumCharge], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_charge")
            @ExcludeMissing
            fun _maximumCharge(): JsonField<String> = maximumCharge

            /**
             * Returns the raw JSON value of [minimumCharge].
             *
             * Unlike [minimumCharge], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_charge")
            @ExcludeMissing
            fun _minimumCharge(): JsonField<String> = minimumCharge

            /**
             * Returns the raw JSON value of [perUnitRate].
             *
             * Unlike [perUnitRate], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("per_unit_rate")
            @ExcludeMissing
            fun _perUnitRate(): JsonField<String> = perUnitRate

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithMinMaxThresholdsConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .maximumCharge()
                 * .minimumCharge()
                 * .perUnitRate()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedWithMinMaxThresholdsConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var maximumCharge: JsonField<String>? = null
                private var minimumCharge: JsonField<String>? = null
                private var perUnitRate: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    groupedWithMinMaxThresholdsConfig: GroupedWithMinMaxThresholdsConfig
                ) = apply {
                    groupingKey = groupedWithMinMaxThresholdsConfig.groupingKey
                    maximumCharge = groupedWithMinMaxThresholdsConfig.maximumCharge
                    minimumCharge = groupedWithMinMaxThresholdsConfig.minimumCharge
                    perUnitRate = groupedWithMinMaxThresholdsConfig.perUnitRate
                    additionalProperties =
                        groupedWithMinMaxThresholdsConfig.additionalProperties.toMutableMap()
                }

                /** The event property used to group before applying thresholds */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** The maximum amount to charge each group */
                fun maximumCharge(maximumCharge: String) =
                    maximumCharge(JsonField.of(maximumCharge))

                /**
                 * Sets [Builder.maximumCharge] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumCharge] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumCharge(maximumCharge: JsonField<String>) = apply {
                    this.maximumCharge = maximumCharge
                }

                /** The minimum amount to charge each group, regardless of usage */
                fun minimumCharge(minimumCharge: String) =
                    minimumCharge(JsonField.of(minimumCharge))

                /**
                 * Sets [Builder.minimumCharge] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumCharge] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumCharge(minimumCharge: JsonField<String>) = apply {
                    this.minimumCharge = minimumCharge
                }

                /** The base price charged per group */
                fun perUnitRate(perUnitRate: String) = perUnitRate(JsonField.of(perUnitRate))

                /**
                 * Sets [Builder.perUnitRate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.perUnitRate] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun perUnitRate(perUnitRate: JsonField<String>) = apply {
                    this.perUnitRate = perUnitRate
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithMinMaxThresholdsConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .maximumCharge()
                 * .minimumCharge()
                 * .perUnitRate()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedWithMinMaxThresholdsConfig =
                    GroupedWithMinMaxThresholdsConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("maximumCharge", maximumCharge),
                        checkRequired("minimumCharge", minimumCharge),
                        checkRequired("perUnitRate", perUnitRate),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithMinMaxThresholdsConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                maximumCharge()
                minimumCharge()
                perUnitRate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (maximumCharge.asKnown() == null) 0 else 1) +
                    (if (minimumCharge.asKnown() == null) 0 else 1) +
                    (if (perUnitRate.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedWithMinMaxThresholdsConfig &&
                    groupingKey == other.groupingKey &&
                    maximumCharge == other.maximumCharge &&
                    minimumCharge == other.minimumCharge &&
                    perUnitRate == other.perUnitRate &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    groupingKey,
                    maximumCharge,
                    minimumCharge,
                    perUnitRate,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMinMaxThresholdsConfig{groupingKey=$groupingKey, maximumCharge=$maximumCharge, minimumCharge=$minimumCharge, perUnitRate=$perUnitRate, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedWithMinMaxThresholds &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedWithMinMaxThresholdsConfig == other.groupedWithMinMaxThresholdsConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedWithMinMaxThresholdsConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMinMaxThresholds{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMinMaxThresholdsConfig=$groupedWithMinMaxThresholdsConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MatrixWithDisplayName
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_with_display_name_config")
            @ExcludeMissing
            matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixWithDisplayNameConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * Configuration for matrix_with_display_name pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("matrix_with_display_name")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixWithDisplayNameConfig].
         *
         * Unlike [matrixWithDisplayNameConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<MatrixWithDisplayNameConfig> =
            matrixWithDisplayNameConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixWithDisplayName].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [MatrixWithDisplayName]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix_with_display_name")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(matrixWithDisplayName: MatrixWithDisplayName) = apply {
                id = matrixWithDisplayName.id
                billableMetric = matrixWithDisplayName.billableMetric
                billingCycleConfiguration = matrixWithDisplayName.billingCycleConfiguration
                billingMode = matrixWithDisplayName.billingMode
                cadence = matrixWithDisplayName.cadence
                compositePriceFilters =
                    matrixWithDisplayName.compositePriceFilters.map { it.toMutableList() }
                conversionRate = matrixWithDisplayName.conversionRate
                conversionRateConfig = matrixWithDisplayName.conversionRateConfig
                createdAt = matrixWithDisplayName.createdAt
                creditAllocation = matrixWithDisplayName.creditAllocation
                currency = matrixWithDisplayName.currency
                discount = matrixWithDisplayName.discount
                externalPriceId = matrixWithDisplayName.externalPriceId
                fixedPriceQuantity = matrixWithDisplayName.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithDisplayName.invoicingCycleConfiguration
                item = matrixWithDisplayName.item
                matrixWithDisplayNameConfig = matrixWithDisplayName.matrixWithDisplayNameConfig
                maximum = matrixWithDisplayName.maximum
                maximumAmount = matrixWithDisplayName.maximumAmount
                metadata = matrixWithDisplayName.metadata
                minimum = matrixWithDisplayName.minimum
                minimumAmount = matrixWithDisplayName.minimumAmount
                modelType = matrixWithDisplayName.modelType
                name = matrixWithDisplayName.name
                planPhaseOrder = matrixWithDisplayName.planPhaseOrder
                priceType = matrixWithDisplayName.priceType
                replacesPriceId = matrixWithDisplayName.replacesPriceId
                dimensionalPriceConfiguration = matrixWithDisplayName.dimensionalPriceConfiguration
                additionalProperties = matrixWithDisplayName.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            /** Configuration for matrix_with_display_name pricing */
            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            /**
             * Sets [Builder.matrixWithDisplayNameConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithDisplayNameConfig] with a well-typed
             * [MatrixWithDisplayNameConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("matrix_with_display_name")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MatrixWithDisplayName].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MatrixWithDisplayName =
                MatrixWithDisplayName(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MatrixWithDisplayName = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            matrixWithDisplayNameConfig().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix_with_display_name")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (matrixWithDisplayNameConfig.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("matrix_with_display_name")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for matrix_with_display_name pricing */
        class MatrixWithDisplayNameConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val dimension: JsonField<String>,
            private val unitAmounts: JsonField<List<UnitAmount>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("dimension")
                @ExcludeMissing
                dimension: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unit_amounts")
                @ExcludeMissing
                unitAmounts: JsonField<List<UnitAmount>> = JsonMissing.of(),
            ) : this(dimension, unitAmounts, mutableMapOf())

            /**
             * Used to determine the unit rate
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimension(): String = dimension.getRequired("dimension")

            /**
             * Apply per unit pricing to each dimension value
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitAmounts(): List<UnitAmount> = unitAmounts.getRequired("unit_amounts")

            /**
             * Returns the raw JSON value of [dimension].
             *
             * Unlike [dimension], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("dimension")
            @ExcludeMissing
            fun _dimension(): JsonField<String> = dimension

            /**
             * Returns the raw JSON value of [unitAmounts].
             *
             * Unlike [unitAmounts], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_amounts")
            @ExcludeMissing
            fun _unitAmounts(): JsonField<List<UnitAmount>> = unitAmounts

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MatrixWithDisplayNameConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .dimension()
                 * .unitAmounts()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [MatrixWithDisplayNameConfig]. */
            class Builder internal constructor() {

                private var dimension: JsonField<String>? = null
                private var unitAmounts: JsonField<MutableList<UnitAmount>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                    apply {
                        dimension = matrixWithDisplayNameConfig.dimension
                        unitAmounts =
                            matrixWithDisplayNameConfig.unitAmounts.map { it.toMutableList() }
                        additionalProperties =
                            matrixWithDisplayNameConfig.additionalProperties.toMutableMap()
                    }

                /** Used to determine the unit rate */
                fun dimension(dimension: String) = dimension(JsonField.of(dimension))

                /**
                 * Sets [Builder.dimension] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimension] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun dimension(dimension: JsonField<String>) = apply { this.dimension = dimension }

                /** Apply per unit pricing to each dimension value */
                fun unitAmounts(unitAmounts: List<UnitAmount>) =
                    unitAmounts(JsonField.of(unitAmounts))

                /**
                 * Sets [Builder.unitAmounts] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitAmounts] with a well-typed
                 * `List<UnitAmount>` value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun unitAmounts(unitAmounts: JsonField<List<UnitAmount>>) = apply {
                    this.unitAmounts = unitAmounts.map { it.toMutableList() }
                }

                /**
                 * Adds a single [UnitAmount] to [unitAmounts].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addUnitAmount(unitAmount: UnitAmount) = apply {
                    unitAmounts =
                        (unitAmounts ?: JsonField.of(mutableListOf())).also {
                            checkKnown("unitAmounts", it).add(unitAmount)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MatrixWithDisplayNameConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .dimension()
                 * .unitAmounts()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): MatrixWithDisplayNameConfig =
                    MatrixWithDisplayNameConfig(
                        checkRequired("dimension", dimension),
                        checkRequired("unitAmounts", unitAmounts).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): MatrixWithDisplayNameConfig = apply {
                if (validated) {
                    return@apply
                }

                dimension()
                unitAmounts().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (dimension.asKnown() == null) 0 else 1) +
                    (unitAmounts.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a unit amount item */
            class UnitAmount
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val dimensionValue: JsonField<String>,
                private val displayName: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("dimension_value")
                    @ExcludeMissing
                    dimensionValue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("display_name")
                    @ExcludeMissing
                    displayName: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(dimensionValue, displayName, unitAmount, mutableMapOf())

                /**
                 * The dimension value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun dimensionValue(): String = dimensionValue.getRequired("dimension_value")

                /**
                 * Display name for this dimension value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun displayName(): String = displayName.getRequired("display_name")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [dimensionValue].
                 *
                 * Unlike [dimensionValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("dimension_value")
                @ExcludeMissing
                fun _dimensionValue(): JsonField<String> = dimensionValue

                /**
                 * Returns the raw JSON value of [displayName].
                 *
                 * Unlike [displayName], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("display_name")
                @ExcludeMissing
                fun _displayName(): JsonField<String> = displayName

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [UnitAmount].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .dimensionValue()
                     * .displayName()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [UnitAmount]. */
                class Builder internal constructor() {

                    private var dimensionValue: JsonField<String>? = null
                    private var displayName: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(unitAmount: UnitAmount) = apply {
                        dimensionValue = unitAmount.dimensionValue
                        displayName = unitAmount.displayName
                        this.unitAmount = unitAmount.unitAmount
                        additionalProperties = unitAmount.additionalProperties.toMutableMap()
                    }

                    /** The dimension value */
                    fun dimensionValue(dimensionValue: String) =
                        dimensionValue(JsonField.of(dimensionValue))

                    /**
                     * Sets [Builder.dimensionValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.dimensionValue] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun dimensionValue(dimensionValue: JsonField<String>) = apply {
                        this.dimensionValue = dimensionValue
                    }

                    /** Display name for this dimension value */
                    fun displayName(displayName: String) = displayName(JsonField.of(displayName))

                    /**
                     * Sets [Builder.displayName] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.displayName] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun displayName(displayName: JsonField<String>) = apply {
                        this.displayName = displayName
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [UnitAmount].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .dimensionValue()
                     * .displayName()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): UnitAmount =
                        UnitAmount(
                            checkRequired("dimensionValue", dimensionValue),
                            checkRequired("displayName", displayName),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): UnitAmount = apply {
                    if (validated) {
                        return@apply
                    }

                    dimensionValue()
                    displayName()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (dimensionValue.asKnown() == null) 0 else 1) +
                        (if (displayName.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UnitAmount &&
                        dimensionValue == other.dimensionValue &&
                        displayName == other.displayName &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(dimensionValue, displayName, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UnitAmount{dimensionValue=$dimensionValue, displayName=$displayName, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is MatrixWithDisplayNameConfig &&
                    dimension == other.dimension &&
                    unitAmounts == other.unitAmounts &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(dimension, unitAmounts, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithDisplayNameConfig{dimension=$dimension, unitAmounts=$unitAmounts, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is MatrixWithDisplayName &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                matrixWithDisplayNameConfig,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithDisplayName{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedTieredPackage
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_tiered_package_config")
            @ExcludeMissing
            groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedTieredPackageConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * Configuration for grouped_tiered_package pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredPackageConfig(): GroupedTieredPackageConfig =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("grouped_tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredPackageConfig].
         *
         * Unlike [groupedTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<GroupedTieredPackageConfig> =
            groupedTieredPackageConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTieredPackage].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(groupedTieredPackage: GroupedTieredPackage) = apply {
                id = groupedTieredPackage.id
                billableMetric = groupedTieredPackage.billableMetric
                billingCycleConfiguration = groupedTieredPackage.billingCycleConfiguration
                billingMode = groupedTieredPackage.billingMode
                cadence = groupedTieredPackage.cadence
                compositePriceFilters =
                    groupedTieredPackage.compositePriceFilters.map { it.toMutableList() }
                conversionRate = groupedTieredPackage.conversionRate
                conversionRateConfig = groupedTieredPackage.conversionRateConfig
                createdAt = groupedTieredPackage.createdAt
                creditAllocation = groupedTieredPackage.creditAllocation
                currency = groupedTieredPackage.currency
                discount = groupedTieredPackage.discount
                externalPriceId = groupedTieredPackage.externalPriceId
                fixedPriceQuantity = groupedTieredPackage.fixedPriceQuantity
                groupedTieredPackageConfig = groupedTieredPackage.groupedTieredPackageConfig
                invoicingCycleConfiguration = groupedTieredPackage.invoicingCycleConfiguration
                item = groupedTieredPackage.item
                maximum = groupedTieredPackage.maximum
                maximumAmount = groupedTieredPackage.maximumAmount
                metadata = groupedTieredPackage.metadata
                minimum = groupedTieredPackage.minimum
                minimumAmount = groupedTieredPackage.minimumAmount
                modelType = groupedTieredPackage.modelType
                name = groupedTieredPackage.name
                planPhaseOrder = groupedTieredPackage.planPhaseOrder
                priceType = groupedTieredPackage.priceType
                replacesPriceId = groupedTieredPackage.replacesPriceId
                dimensionalPriceConfiguration = groupedTieredPackage.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            /** Configuration for grouped_tiered_package pricing */
            fun groupedTieredPackageConfig(groupedTieredPackageConfig: GroupedTieredPackageConfig) =
                groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            /**
             * Sets [Builder.groupedTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredPackageConfig] with a well-typed
             * [GroupedTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("grouped_tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedTieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedTieredPackage =
                GroupedTieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedTieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredPackageConfig().validate()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (groupedTieredPackageConfig.asKnown()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("grouped_tiered_package")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for grouped_tiered_package pricing */
        class GroupedTieredPackageConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val packageSize: JsonField<String>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("package_size")
                @ExcludeMissing
                packageSize: JsonField<String> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(groupingKey, packageSize, tiers, mutableMapOf())

            /**
             * The event property used to group before tiering
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * Package size
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): String = packageSize.getRequired("package_size")

            /**
             * Apply tiered pricing after rounding up the quantity to the package size. Tiers are
             * defined using exclusive lower bounds.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<String> = packageSize

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedTieredPackageConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .packageSize()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [GroupedTieredPackageConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var packageSize: JsonField<String>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(groupedTieredPackageConfig: GroupedTieredPackageConfig) = apply {
                    groupingKey = groupedTieredPackageConfig.groupingKey
                    packageSize = groupedTieredPackageConfig.packageSize
                    tiers = groupedTieredPackageConfig.tiers.map { it.toMutableList() }
                    additionalProperties =
                        groupedTieredPackageConfig.additionalProperties.toMutableMap()
                }

                /** The event property used to group before tiering */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** Package size */
                fun packageSize(packageSize: String) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<String>) = apply {
                    this.packageSize = packageSize
                }

                /**
                 * Apply tiered pricing after rounding up the quantity to the package size. Tiers
                 * are defined using exclusive lower bounds.
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedTieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .packageSize()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): GroupedTieredPackageConfig =
                    GroupedTieredPackageConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("packageSize", packageSize),
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): GroupedTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                packageSize()
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (packageSize.asKnown() == null) 0 else 1) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val perUnit: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("per_unit")
                    @ExcludeMissing
                    perUnit: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                ) : this(perUnit, tierLowerBound, mutableMapOf())

                /**
                 * Price per package
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun perUnit(): String = perUnit.getRequired("per_unit")

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Returns the raw JSON value of [perUnit].
                 *
                 * Unlike [perUnit], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("per_unit")
                @ExcludeMissing
                fun _perUnit(): JsonField<String> = perUnit

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var perUnit: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        perUnit = tier.perUnit
                        tierLowerBound = tier.tierLowerBound
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Price per package */
                    fun perUnit(perUnit: String) = perUnit(JsonField.of(perUnit))

                    /**
                     * Sets [Builder.perUnit] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.perUnit] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun perUnit(perUnit: JsonField<String>) = apply { this.perUnit = perUnit }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .perUnit()
                     * .tierLowerBound()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("perUnit", perUnit),
                            checkRequired("tierLowerBound", tierLowerBound),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    perUnit()
                    tierLowerBound()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (perUnit.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        perUnit == other.perUnit &&
                        tierLowerBound == other.tierLowerBound &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(perUnit, tierLowerBound, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{perUnit=$perUnit, tierLowerBound=$tierLowerBound, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is GroupedTieredPackageConfig &&
                    groupingKey == other.groupingKey &&
                    packageSize == other.packageSize &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(groupingKey, packageSize, tiers, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredPackageConfig{groupingKey=$groupingKey, packageSize=$packageSize, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is GroupedTieredPackage &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                groupedTieredPackageConfig == other.groupedTieredPackageConfig &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                groupedTieredPackageConfig,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredPackageConfig=$groupedTieredPackageConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MaxGroupTieredPackage
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("max_group_tiered_package_config")
            @ExcludeMissing
            maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maxGroupTieredPackageConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * Configuration for max_group_tiered_package pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun maxGroupTieredPackageConfig(): MaxGroupTieredPackageConfig =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("max_group_tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maxGroupTieredPackageConfig].
         *
         * Unlike [maxGroupTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<MaxGroupTieredPackageConfig> =
            maxGroupTieredPackageConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MaxGroupTieredPackage].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [MaxGroupTieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("max_group_tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(maxGroupTieredPackage: MaxGroupTieredPackage) = apply {
                id = maxGroupTieredPackage.id
                billableMetric = maxGroupTieredPackage.billableMetric
                billingCycleConfiguration = maxGroupTieredPackage.billingCycleConfiguration
                billingMode = maxGroupTieredPackage.billingMode
                cadence = maxGroupTieredPackage.cadence
                compositePriceFilters =
                    maxGroupTieredPackage.compositePriceFilters.map { it.toMutableList() }
                conversionRate = maxGroupTieredPackage.conversionRate
                conversionRateConfig = maxGroupTieredPackage.conversionRateConfig
                createdAt = maxGroupTieredPackage.createdAt
                creditAllocation = maxGroupTieredPackage.creditAllocation
                currency = maxGroupTieredPackage.currency
                discount = maxGroupTieredPackage.discount
                externalPriceId = maxGroupTieredPackage.externalPriceId
                fixedPriceQuantity = maxGroupTieredPackage.fixedPriceQuantity
                invoicingCycleConfiguration = maxGroupTieredPackage.invoicingCycleConfiguration
                item = maxGroupTieredPackage.item
                maxGroupTieredPackageConfig = maxGroupTieredPackage.maxGroupTieredPackageConfig
                maximum = maxGroupTieredPackage.maximum
                maximumAmount = maxGroupTieredPackage.maximumAmount
                metadata = maxGroupTieredPackage.metadata
                minimum = maxGroupTieredPackage.minimum
                minimumAmount = maxGroupTieredPackage.minimumAmount
                modelType = maxGroupTieredPackage.modelType
                name = maxGroupTieredPackage.name
                planPhaseOrder = maxGroupTieredPackage.planPhaseOrder
                priceType = maxGroupTieredPackage.priceType
                replacesPriceId = maxGroupTieredPackage.replacesPriceId
                dimensionalPriceConfiguration = maxGroupTieredPackage.dimensionalPriceConfiguration
                additionalProperties = maxGroupTieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            /** Configuration for max_group_tiered_package pricing */
            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            /**
             * Sets [Builder.maxGroupTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maxGroupTieredPackageConfig] with a well-typed
             * [MaxGroupTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("max_group_tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MaxGroupTieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MaxGroupTieredPackage =
                MaxGroupTieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MaxGroupTieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maxGroupTieredPackageConfig().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("max_group_tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maxGroupTieredPackageConfig.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("max_group_tiered_package")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for max_group_tiered_package pricing */
        class MaxGroupTieredPackageConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val groupingKey: JsonField<String>,
            private val packageSize: JsonField<String>,
            private val tiers: JsonField<List<Tier>>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("package_size")
                @ExcludeMissing
                packageSize: JsonField<String> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
            ) : this(groupingKey, packageSize, tiers, mutableMapOf())

            /**
             * The event property used to group before tiering the group with the highest value
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun groupingKey(): String = groupingKey.getRequired("grouping_key")

            /**
             * Package size
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): String = packageSize.getRequired("package_size")

            /**
             * Apply tiered pricing to the largest group after grouping with the provided key.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<String> = packageSize

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MaxGroupTieredPackageConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .packageSize()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [MaxGroupTieredPackageConfig]. */
            class Builder internal constructor() {

                private var groupingKey: JsonField<String>? = null
                private var packageSize: JsonField<String>? = null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig) =
                    apply {
                        groupingKey = maxGroupTieredPackageConfig.groupingKey
                        packageSize = maxGroupTieredPackageConfig.packageSize
                        tiers = maxGroupTieredPackageConfig.tiers.map { it.toMutableList() }
                        additionalProperties =
                            maxGroupTieredPackageConfig.additionalProperties.toMutableMap()
                    }

                /**
                 * The event property used to group before tiering the group with the highest value
                 */
                fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                /** Package size */
                fun packageSize(packageSize: String) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<String>) = apply {
                    this.packageSize = packageSize
                }

                /**
                 * Apply tiered pricing to the largest group after grouping with the provided key.
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MaxGroupTieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .groupingKey()
                 * .packageSize()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): MaxGroupTieredPackageConfig =
                    MaxGroupTieredPackageConfig(
                        checkRequired("groupingKey", groupingKey),
                        checkRequired("packageSize", packageSize),
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): MaxGroupTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                groupingKey()
                packageSize()
                tiers().forEach { it.validate() }
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (groupingKey.asKnown() == null) 0 else 1) +
                    (if (packageSize.asKnown() == null) 0 else 1) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

            /** Configuration for a single tier */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        tierLowerBound = tier.tierLowerBound
                        unitAmount = tier.unitAmount
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is MaxGroupTieredPackageConfig &&
                    groupingKey == other.groupingKey &&
                    packageSize == other.packageSize &&
                    tiers == other.tiers &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(groupingKey, packageSize, tiers, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MaxGroupTieredPackageConfig{groupingKey=$groupingKey, packageSize=$packageSize, tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is MaxGroupTieredPackage &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maxGroupTieredPackageConfig,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MaxGroupTieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ScalableMatrixWithUnitPricing
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<ScalableMatrixWithUnitPricingConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("scalable_matrix_with_unit_pricing_config")
            @ExcludeMissing
            scalableMatrixWithUnitPricingConfig: JsonField<ScalableMatrixWithUnitPricingConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            scalableMatrixWithUnitPricingConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("scalable_matrix_with_unit_pricing")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for scalable_matrix_with_unit_pricing pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithUnitPricingConfig(): ScalableMatrixWithUnitPricingConfig =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [scalableMatrixWithUnitPricingConfig].
         *
         * Unlike [scalableMatrixWithUnitPricingConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<ScalableMatrixWithUnitPricingConfig> =
            scalableMatrixWithUnitPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithUnitPricing].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithUnitPricing]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("scalable_matrix_with_unit_pricing")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<ScalableMatrixWithUnitPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing) =
                apply {
                    id = scalableMatrixWithUnitPricing.id
                    billableMetric = scalableMatrixWithUnitPricing.billableMetric
                    billingCycleConfiguration =
                        scalableMatrixWithUnitPricing.billingCycleConfiguration
                    billingMode = scalableMatrixWithUnitPricing.billingMode
                    cadence = scalableMatrixWithUnitPricing.cadence
                    compositePriceFilters =
                        scalableMatrixWithUnitPricing.compositePriceFilters.map {
                            it.toMutableList()
                        }
                    conversionRate = scalableMatrixWithUnitPricing.conversionRate
                    conversionRateConfig = scalableMatrixWithUnitPricing.conversionRateConfig
                    createdAt = scalableMatrixWithUnitPricing.createdAt
                    creditAllocation = scalableMatrixWithUnitPricing.creditAllocation
                    currency = scalableMatrixWithUnitPricing.currency
                    discount = scalableMatrixWithUnitPricing.discount
                    externalPriceId = scalableMatrixWithUnitPricing.externalPriceId
                    fixedPriceQuantity = scalableMatrixWithUnitPricing.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        scalableMatrixWithUnitPricing.invoicingCycleConfiguration
                    item = scalableMatrixWithUnitPricing.item
                    maximum = scalableMatrixWithUnitPricing.maximum
                    maximumAmount = scalableMatrixWithUnitPricing.maximumAmount
                    metadata = scalableMatrixWithUnitPricing.metadata
                    minimum = scalableMatrixWithUnitPricing.minimum
                    minimumAmount = scalableMatrixWithUnitPricing.minimumAmount
                    modelType = scalableMatrixWithUnitPricing.modelType
                    name = scalableMatrixWithUnitPricing.name
                    planPhaseOrder = scalableMatrixWithUnitPricing.planPhaseOrder
                    priceType = scalableMatrixWithUnitPricing.priceType
                    replacesPriceId = scalableMatrixWithUnitPricing.replacesPriceId
                    scalableMatrixWithUnitPricingConfig =
                        scalableMatrixWithUnitPricing.scalableMatrixWithUnitPricingConfig
                    dimensionalPriceConfiguration =
                        scalableMatrixWithUnitPricing.dimensionalPriceConfiguration
                    additionalProperties =
                        scalableMatrixWithUnitPricing.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("scalable_matrix_with_unit_pricing")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for scalable_matrix_with_unit_pricing pricing */
            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithUnitPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithUnitPricingConfig] with a
             * well-typed [ScalableMatrixWithUnitPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<ScalableMatrixWithUnitPricingConfig>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ScalableMatrixWithUnitPricing].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ScalableMatrixWithUnitPricing =
                ScalableMatrixWithUnitPricing(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithUnitPricing = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("scalable_matrix_with_unit_pricing")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            scalableMatrixWithUnitPricingConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("scalable_matrix_with_unit_pricing")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (scalableMatrixWithUnitPricingConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for scalable_matrix_with_unit_pricing pricing */
        class ScalableMatrixWithUnitPricingConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val firstDimension: JsonField<String>,
            private val matrixScalingFactors: JsonField<List<MatrixScalingFactor>>,
            private val unitPrice: JsonField<String>,
            private val prorate: JsonField<Boolean>,
            private val secondDimension: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("first_dimension")
                @ExcludeMissing
                firstDimension: JsonField<String> = JsonMissing.of(),
                @JsonProperty("matrix_scaling_factors")
                @ExcludeMissing
                matrixScalingFactors: JsonField<List<MatrixScalingFactor>> = JsonMissing.of(),
                @JsonProperty("unit_price")
                @ExcludeMissing
                unitPrice: JsonField<String> = JsonMissing.of(),
                @JsonProperty("prorate")
                @ExcludeMissing
                prorate: JsonField<Boolean> = JsonMissing.of(),
                @JsonProperty("second_dimension")
                @ExcludeMissing
                secondDimension: JsonField<String> = JsonMissing.of(),
            ) : this(
                firstDimension,
                matrixScalingFactors,
                unitPrice,
                prorate,
                secondDimension,
                mutableMapOf(),
            )

            /**
             * Used to determine the unit rate
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun firstDimension(): String = firstDimension.getRequired("first_dimension")

            /**
             * Apply a scaling factor to each dimension
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun matrixScalingFactors(): List<MatrixScalingFactor> =
                matrixScalingFactors.getRequired("matrix_scaling_factors")

            /**
             * The final unit price to rate against the output of the matrix
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitPrice(): String = unitPrice.getRequired("unit_price")

            /**
             * If true, the unit price will be prorated to the billing period
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun prorate(): Boolean? = prorate.getNullable("prorate")

            /**
             * Used to determine the unit rate (optional)
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun secondDimension(): String? = secondDimension.getNullable("second_dimension")

            /**
             * Returns the raw JSON value of [firstDimension].
             *
             * Unlike [firstDimension], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("first_dimension")
            @ExcludeMissing
            fun _firstDimension(): JsonField<String> = firstDimension

            /**
             * Returns the raw JSON value of [matrixScalingFactors].
             *
             * Unlike [matrixScalingFactors], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("matrix_scaling_factors")
            @ExcludeMissing
            fun _matrixScalingFactors(): JsonField<List<MatrixScalingFactor>> = matrixScalingFactors

            /**
             * Returns the raw JSON value of [unitPrice].
             *
             * Unlike [unitPrice], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_price")
            @ExcludeMissing
            fun _unitPrice(): JsonField<String> = unitPrice

            /**
             * Returns the raw JSON value of [prorate].
             *
             * Unlike [prorate], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("prorate") @ExcludeMissing fun _prorate(): JsonField<Boolean> = prorate

            /**
             * Returns the raw JSON value of [secondDimension].
             *
             * Unlike [secondDimension], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("second_dimension")
            @ExcludeMissing
            fun _secondDimension(): JsonField<String> = secondDimension

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithUnitPricingConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .firstDimension()
                 * .matrixScalingFactors()
                 * .unitPrice()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithUnitPricingConfig]. */
            class Builder internal constructor() {

                private var firstDimension: JsonField<String>? = null
                private var matrixScalingFactors: JsonField<MutableList<MatrixScalingFactor>>? =
                    null
                private var unitPrice: JsonField<String>? = null
                private var prorate: JsonField<Boolean> = JsonMissing.of()
                private var secondDimension: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
                ) = apply {
                    firstDimension = scalableMatrixWithUnitPricingConfig.firstDimension
                    matrixScalingFactors =
                        scalableMatrixWithUnitPricingConfig.matrixScalingFactors.map {
                            it.toMutableList()
                        }
                    unitPrice = scalableMatrixWithUnitPricingConfig.unitPrice
                    prorate = scalableMatrixWithUnitPricingConfig.prorate
                    secondDimension = scalableMatrixWithUnitPricingConfig.secondDimension
                    additionalProperties =
                        scalableMatrixWithUnitPricingConfig.additionalProperties.toMutableMap()
                }

                /** Used to determine the unit rate */
                fun firstDimension(firstDimension: String) =
                    firstDimension(JsonField.of(firstDimension))

                /**
                 * Sets [Builder.firstDimension] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.firstDimension] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun firstDimension(firstDimension: JsonField<String>) = apply {
                    this.firstDimension = firstDimension
                }

                /** Apply a scaling factor to each dimension */
                fun matrixScalingFactors(matrixScalingFactors: List<MatrixScalingFactor>) =
                    matrixScalingFactors(JsonField.of(matrixScalingFactors))

                /**
                 * Sets [Builder.matrixScalingFactors] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.matrixScalingFactors] with a well-typed
                 * `List<MatrixScalingFactor>` value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun matrixScalingFactors(
                    matrixScalingFactors: JsonField<List<MatrixScalingFactor>>
                ) = apply {
                    this.matrixScalingFactors = matrixScalingFactors.map { it.toMutableList() }
                }

                /**
                 * Adds a single [MatrixScalingFactor] to [matrixScalingFactors].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addMatrixScalingFactor(matrixScalingFactor: MatrixScalingFactor) = apply {
                    matrixScalingFactors =
                        (matrixScalingFactors ?: JsonField.of(mutableListOf())).also {
                            checkKnown("matrixScalingFactors", it).add(matrixScalingFactor)
                        }
                }

                /** The final unit price to rate against the output of the matrix */
                fun unitPrice(unitPrice: String) = unitPrice(JsonField.of(unitPrice))

                /**
                 * Sets [Builder.unitPrice] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitPrice] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitPrice(unitPrice: JsonField<String>) = apply { this.unitPrice = unitPrice }

                /** If true, the unit price will be prorated to the billing period */
                fun prorate(prorate: Boolean?) = prorate(JsonField.ofNullable(prorate))

                /**
                 * Alias for [Builder.prorate].
                 *
                 * This unboxed primitive overload exists for backwards compatibility.
                 */
                fun prorate(prorate: Boolean) = prorate(prorate as Boolean?)

                /**
                 * Sets [Builder.prorate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.prorate] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun prorate(prorate: JsonField<Boolean>) = apply { this.prorate = prorate }

                /** Used to determine the unit rate (optional) */
                fun secondDimension(secondDimension: String?) =
                    secondDimension(JsonField.ofNullable(secondDimension))

                /**
                 * Sets [Builder.secondDimension] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.secondDimension] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun secondDimension(secondDimension: JsonField<String>) = apply {
                    this.secondDimension = secondDimension
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ScalableMatrixWithUnitPricingConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .firstDimension()
                 * .matrixScalingFactors()
                 * .unitPrice()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): ScalableMatrixWithUnitPricingConfig =
                    ScalableMatrixWithUnitPricingConfig(
                        checkRequired("firstDimension", firstDimension),
                        checkRequired("matrixScalingFactors", matrixScalingFactors).map {
                            it.toImmutable()
                        },
                        checkRequired("unitPrice", unitPrice),
                        prorate,
                        secondDimension,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithUnitPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                firstDimension()
                matrixScalingFactors().forEach { it.validate() }
                unitPrice()
                prorate()
                secondDimension()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (firstDimension.asKnown() == null) 0 else 1) +
                    (matrixScalingFactors.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (unitPrice.asKnown() == null) 0 else 1) +
                    (if (prorate.asKnown() == null) 0 else 1) +
                    (if (secondDimension.asKnown() == null) 0 else 1)

            /** Configuration for a single matrix scaling factor */
            class MatrixScalingFactor
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val firstDimensionValue: JsonField<String>,
                private val scalingFactor: JsonField<String>,
                private val secondDimensionValue: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("first_dimension_value")
                    @ExcludeMissing
                    firstDimensionValue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("scaling_factor")
                    @ExcludeMissing
                    scalingFactor: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("second_dimension_value")
                    @ExcludeMissing
                    secondDimensionValue: JsonField<String> = JsonMissing.of(),
                ) : this(firstDimensionValue, scalingFactor, secondDimensionValue, mutableMapOf())

                /**
                 * First dimension value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun firstDimensionValue(): String =
                    firstDimensionValue.getRequired("first_dimension_value")

                /**
                 * Scaling factor
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun scalingFactor(): String = scalingFactor.getRequired("scaling_factor")

                /**
                 * Second dimension value (optional)
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun secondDimensionValue(): String? =
                    secondDimensionValue.getNullable("second_dimension_value")

                /**
                 * Returns the raw JSON value of [firstDimensionValue].
                 *
                 * Unlike [firstDimensionValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("first_dimension_value")
                @ExcludeMissing
                fun _firstDimensionValue(): JsonField<String> = firstDimensionValue

                /**
                 * Returns the raw JSON value of [scalingFactor].
                 *
                 * Unlike [scalingFactor], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("scaling_factor")
                @ExcludeMissing
                fun _scalingFactor(): JsonField<String> = scalingFactor

                /**
                 * Returns the raw JSON value of [secondDimensionValue].
                 *
                 * Unlike [secondDimensionValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("second_dimension_value")
                @ExcludeMissing
                fun _secondDimensionValue(): JsonField<String> = secondDimensionValue

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [MatrixScalingFactor].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .firstDimensionValue()
                     * .scalingFactor()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [MatrixScalingFactor]. */
                class Builder internal constructor() {

                    private var firstDimensionValue: JsonField<String>? = null
                    private var scalingFactor: JsonField<String>? = null
                    private var secondDimensionValue: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(matrixScalingFactor: MatrixScalingFactor) = apply {
                        firstDimensionValue = matrixScalingFactor.firstDimensionValue
                        scalingFactor = matrixScalingFactor.scalingFactor
                        secondDimensionValue = matrixScalingFactor.secondDimensionValue
                        additionalProperties =
                            matrixScalingFactor.additionalProperties.toMutableMap()
                    }

                    /** First dimension value */
                    fun firstDimensionValue(firstDimensionValue: String) =
                        firstDimensionValue(JsonField.of(firstDimensionValue))

                    /**
                     * Sets [Builder.firstDimensionValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.firstDimensionValue] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun firstDimensionValue(firstDimensionValue: JsonField<String>) = apply {
                        this.firstDimensionValue = firstDimensionValue
                    }

                    /** Scaling factor */
                    fun scalingFactor(scalingFactor: String) =
                        scalingFactor(JsonField.of(scalingFactor))

                    /**
                     * Sets [Builder.scalingFactor] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.scalingFactor] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun scalingFactor(scalingFactor: JsonField<String>) = apply {
                        this.scalingFactor = scalingFactor
                    }

                    /** Second dimension value (optional) */
                    fun secondDimensionValue(secondDimensionValue: String?) =
                        secondDimensionValue(JsonField.ofNullable(secondDimensionValue))

                    /**
                     * Sets [Builder.secondDimensionValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.secondDimensionValue] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun secondDimensionValue(secondDimensionValue: JsonField<String>) = apply {
                        this.secondDimensionValue = secondDimensionValue
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [MatrixScalingFactor].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .firstDimensionValue()
                     * .scalingFactor()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): MatrixScalingFactor =
                        MatrixScalingFactor(
                            checkRequired("firstDimensionValue", firstDimensionValue),
                            checkRequired("scalingFactor", scalingFactor),
                            secondDimensionValue,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): MatrixScalingFactor = apply {
                    if (validated) {
                        return@apply
                    }

                    firstDimensionValue()
                    scalingFactor()
                    secondDimensionValue()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (firstDimensionValue.asKnown() == null) 0 else 1) +
                        (if (scalingFactor.asKnown() == null) 0 else 1) +
                        (if (secondDimensionValue.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MatrixScalingFactor &&
                        firstDimensionValue == other.firstDimensionValue &&
                        scalingFactor == other.scalingFactor &&
                        secondDimensionValue == other.secondDimensionValue &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        firstDimensionValue,
                        scalingFactor,
                        secondDimensionValue,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixScalingFactor{firstDimensionValue=$firstDimensionValue, scalingFactor=$scalingFactor, secondDimensionValue=$secondDimensionValue, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is ScalableMatrixWithUnitPricingConfig &&
                    firstDimension == other.firstDimension &&
                    matrixScalingFactors == other.matrixScalingFactors &&
                    unitPrice == other.unitPrice &&
                    prorate == other.prorate &&
                    secondDimension == other.secondDimension &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    firstDimension,
                    matrixScalingFactors,
                    unitPrice,
                    prorate,
                    secondDimension,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithUnitPricingConfig{firstDimension=$firstDimension, matrixScalingFactors=$matrixScalingFactors, unitPrice=$unitPrice, prorate=$prorate, secondDimension=$secondDimension, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ScalableMatrixWithUnitPricing &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                scalableMatrixWithUnitPricingConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithUnitPricing{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ScalableMatrixWithTieredPricing
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<ScalableMatrixWithTieredPricingConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("scalable_matrix_with_tiered_pricing_config")
            @ExcludeMissing
            scalableMatrixWithTieredPricingConfig:
                JsonField<ScalableMatrixWithTieredPricingConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            scalableMatrixWithTieredPricingConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("scalable_matrix_with_tiered_pricing")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * Configuration for scalable_matrix_with_tiered_pricing pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithTieredPricingConfig(): ScalableMatrixWithTieredPricingConfig =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [scalableMatrixWithTieredPricingConfig].
         *
         * Unlike [scalableMatrixWithTieredPricingConfig], this method doesn't throw if the JSON
         * field has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig():
            JsonField<ScalableMatrixWithTieredPricingConfig> = scalableMatrixWithTieredPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithTieredPricing].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithTieredPricing]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("scalable_matrix_with_tiered_pricing")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<ScalableMatrixWithTieredPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing) =
                apply {
                    id = scalableMatrixWithTieredPricing.id
                    billableMetric = scalableMatrixWithTieredPricing.billableMetric
                    billingCycleConfiguration =
                        scalableMatrixWithTieredPricing.billingCycleConfiguration
                    billingMode = scalableMatrixWithTieredPricing.billingMode
                    cadence = scalableMatrixWithTieredPricing.cadence
                    compositePriceFilters =
                        scalableMatrixWithTieredPricing.compositePriceFilters.map {
                            it.toMutableList()
                        }
                    conversionRate = scalableMatrixWithTieredPricing.conversionRate
                    conversionRateConfig = scalableMatrixWithTieredPricing.conversionRateConfig
                    createdAt = scalableMatrixWithTieredPricing.createdAt
                    creditAllocation = scalableMatrixWithTieredPricing.creditAllocation
                    currency = scalableMatrixWithTieredPricing.currency
                    discount = scalableMatrixWithTieredPricing.discount
                    externalPriceId = scalableMatrixWithTieredPricing.externalPriceId
                    fixedPriceQuantity = scalableMatrixWithTieredPricing.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        scalableMatrixWithTieredPricing.invoicingCycleConfiguration
                    item = scalableMatrixWithTieredPricing.item
                    maximum = scalableMatrixWithTieredPricing.maximum
                    maximumAmount = scalableMatrixWithTieredPricing.maximumAmount
                    metadata = scalableMatrixWithTieredPricing.metadata
                    minimum = scalableMatrixWithTieredPricing.minimum
                    minimumAmount = scalableMatrixWithTieredPricing.minimumAmount
                    modelType = scalableMatrixWithTieredPricing.modelType
                    name = scalableMatrixWithTieredPricing.name
                    planPhaseOrder = scalableMatrixWithTieredPricing.planPhaseOrder
                    priceType = scalableMatrixWithTieredPricing.priceType
                    replacesPriceId = scalableMatrixWithTieredPricing.replacesPriceId
                    scalableMatrixWithTieredPricingConfig =
                        scalableMatrixWithTieredPricing.scalableMatrixWithTieredPricingConfig
                    dimensionalPriceConfiguration =
                        scalableMatrixWithTieredPricing.dimensionalPriceConfiguration
                    additionalProperties =
                        scalableMatrixWithTieredPricing.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("scalable_matrix_with_tiered_pricing")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            /** Configuration for scalable_matrix_with_tiered_pricing pricing */
            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithTieredPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithTieredPricingConfig] with a
             * well-typed [ScalableMatrixWithTieredPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig:
                    JsonField<ScalableMatrixWithTieredPricingConfig>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ScalableMatrixWithTieredPricing].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ScalableMatrixWithTieredPricing =
                ScalableMatrixWithTieredPricing(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithTieredPricing = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("scalable_matrix_with_tiered_pricing")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            scalableMatrixWithTieredPricingConfig().validate()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let {
                    if (it == JsonValue.from("scalable_matrix_with_tiered_pricing")) 1 else 0
                } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (scalableMatrixWithTieredPricingConfig.asKnown()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for scalable_matrix_with_tiered_pricing pricing */
        class ScalableMatrixWithTieredPricingConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val firstDimension: JsonField<String>,
            private val matrixScalingFactors: JsonField<List<MatrixScalingFactor>>,
            private val tiers: JsonField<List<Tier>>,
            private val secondDimension: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("first_dimension")
                @ExcludeMissing
                firstDimension: JsonField<String> = JsonMissing.of(),
                @JsonProperty("matrix_scaling_factors")
                @ExcludeMissing
                matrixScalingFactors: JsonField<List<MatrixScalingFactor>> = JsonMissing.of(),
                @JsonProperty("tiers")
                @ExcludeMissing
                tiers: JsonField<List<Tier>> = JsonMissing.of(),
                @JsonProperty("second_dimension")
                @ExcludeMissing
                secondDimension: JsonField<String> = JsonMissing.of(),
            ) : this(firstDimension, matrixScalingFactors, tiers, secondDimension, mutableMapOf())

            /**
             * Used for the scalable matrix first dimension
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun firstDimension(): String = firstDimension.getRequired("first_dimension")

            /**
             * Apply a scaling factor to each dimension
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun matrixScalingFactors(): List<MatrixScalingFactor> =
                matrixScalingFactors.getRequired("matrix_scaling_factors")

            /**
             * Tier pricing structure
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Used for the scalable matrix second dimension (optional)
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun secondDimension(): String? = secondDimension.getNullable("second_dimension")

            /**
             * Returns the raw JSON value of [firstDimension].
             *
             * Unlike [firstDimension], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("first_dimension")
            @ExcludeMissing
            fun _firstDimension(): JsonField<String> = firstDimension

            /**
             * Returns the raw JSON value of [matrixScalingFactors].
             *
             * Unlike [matrixScalingFactors], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("matrix_scaling_factors")
            @ExcludeMissing
            fun _matrixScalingFactors(): JsonField<List<MatrixScalingFactor>> = matrixScalingFactors

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            /**
             * Returns the raw JSON value of [secondDimension].
             *
             * Unlike [secondDimension], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("second_dimension")
            @ExcludeMissing
            fun _secondDimension(): JsonField<String> = secondDimension

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithTieredPricingConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .firstDimension()
                 * .matrixScalingFactors()
                 * .tiers()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithTieredPricingConfig]. */
            class Builder internal constructor() {

                private var firstDimension: JsonField<String>? = null
                private var matrixScalingFactors: JsonField<MutableList<MatrixScalingFactor>>? =
                    null
                private var tiers: JsonField<MutableList<Tier>>? = null
                private var secondDimension: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
                ) = apply {
                    firstDimension = scalableMatrixWithTieredPricingConfig.firstDimension
                    matrixScalingFactors =
                        scalableMatrixWithTieredPricingConfig.matrixScalingFactors.map {
                            it.toMutableList()
                        }
                    tiers = scalableMatrixWithTieredPricingConfig.tiers.map { it.toMutableList() }
                    secondDimension = scalableMatrixWithTieredPricingConfig.secondDimension
                    additionalProperties =
                        scalableMatrixWithTieredPricingConfig.additionalProperties.toMutableMap()
                }

                /** Used for the scalable matrix first dimension */
                fun firstDimension(firstDimension: String) =
                    firstDimension(JsonField.of(firstDimension))

                /**
                 * Sets [Builder.firstDimension] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.firstDimension] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun firstDimension(firstDimension: JsonField<String>) = apply {
                    this.firstDimension = firstDimension
                }

                /** Apply a scaling factor to each dimension */
                fun matrixScalingFactors(matrixScalingFactors: List<MatrixScalingFactor>) =
                    matrixScalingFactors(JsonField.of(matrixScalingFactors))

                /**
                 * Sets [Builder.matrixScalingFactors] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.matrixScalingFactors] with a well-typed
                 * `List<MatrixScalingFactor>` value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun matrixScalingFactors(
                    matrixScalingFactors: JsonField<List<MatrixScalingFactor>>
                ) = apply {
                    this.matrixScalingFactors = matrixScalingFactors.map { it.toMutableList() }
                }

                /**
                 * Adds a single [MatrixScalingFactor] to [matrixScalingFactors].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addMatrixScalingFactor(matrixScalingFactor: MatrixScalingFactor) = apply {
                    matrixScalingFactors =
                        (matrixScalingFactors ?: JsonField.of(mutableListOf())).also {
                            checkKnown("matrixScalingFactors", it).add(matrixScalingFactor)
                        }
                }

                /** Tier pricing structure */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                /** Used for the scalable matrix second dimension (optional) */
                fun secondDimension(secondDimension: String?) =
                    secondDimension(JsonField.ofNullable(secondDimension))

                /**
                 * Sets [Builder.secondDimension] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.secondDimension] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun secondDimension(secondDimension: JsonField<String>) = apply {
                    this.secondDimension = secondDimension
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ScalableMatrixWithTieredPricingConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .firstDimension()
                 * .matrixScalingFactors()
                 * .tiers()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): ScalableMatrixWithTieredPricingConfig =
                    ScalableMatrixWithTieredPricingConfig(
                        checkRequired("firstDimension", firstDimension),
                        checkRequired("matrixScalingFactors", matrixScalingFactors).map {
                            it.toImmutable()
                        },
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        secondDimension,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithTieredPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                firstDimension()
                matrixScalingFactors().forEach { it.validate() }
                tiers().forEach { it.validate() }
                secondDimension()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (firstDimension.asKnown() == null) 0 else 1) +
                    (matrixScalingFactors.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (tiers.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (secondDimension.asKnown() == null) 0 else 1)

            /** Configuration for a single matrix scaling factor */
            class MatrixScalingFactor
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val firstDimensionValue: JsonField<String>,
                private val scalingFactor: JsonField<String>,
                private val secondDimensionValue: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("first_dimension_value")
                    @ExcludeMissing
                    firstDimensionValue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("scaling_factor")
                    @ExcludeMissing
                    scalingFactor: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("second_dimension_value")
                    @ExcludeMissing
                    secondDimensionValue: JsonField<String> = JsonMissing.of(),
                ) : this(firstDimensionValue, scalingFactor, secondDimensionValue, mutableMapOf())

                /**
                 * First dimension value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun firstDimensionValue(): String =
                    firstDimensionValue.getRequired("first_dimension_value")

                /**
                 * Scaling factor
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun scalingFactor(): String = scalingFactor.getRequired("scaling_factor")

                /**
                 * Second dimension value (optional)
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun secondDimensionValue(): String? =
                    secondDimensionValue.getNullable("second_dimension_value")

                /**
                 * Returns the raw JSON value of [firstDimensionValue].
                 *
                 * Unlike [firstDimensionValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("first_dimension_value")
                @ExcludeMissing
                fun _firstDimensionValue(): JsonField<String> = firstDimensionValue

                /**
                 * Returns the raw JSON value of [scalingFactor].
                 *
                 * Unlike [scalingFactor], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("scaling_factor")
                @ExcludeMissing
                fun _scalingFactor(): JsonField<String> = scalingFactor

                /**
                 * Returns the raw JSON value of [secondDimensionValue].
                 *
                 * Unlike [secondDimensionValue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("second_dimension_value")
                @ExcludeMissing
                fun _secondDimensionValue(): JsonField<String> = secondDimensionValue

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [MatrixScalingFactor].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .firstDimensionValue()
                     * .scalingFactor()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [MatrixScalingFactor]. */
                class Builder internal constructor() {

                    private var firstDimensionValue: JsonField<String>? = null
                    private var scalingFactor: JsonField<String>? = null
                    private var secondDimensionValue: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(matrixScalingFactor: MatrixScalingFactor) = apply {
                        firstDimensionValue = matrixScalingFactor.firstDimensionValue
                        scalingFactor = matrixScalingFactor.scalingFactor
                        secondDimensionValue = matrixScalingFactor.secondDimensionValue
                        additionalProperties =
                            matrixScalingFactor.additionalProperties.toMutableMap()
                    }

                    /** First dimension value */
                    fun firstDimensionValue(firstDimensionValue: String) =
                        firstDimensionValue(JsonField.of(firstDimensionValue))

                    /**
                     * Sets [Builder.firstDimensionValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.firstDimensionValue] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun firstDimensionValue(firstDimensionValue: JsonField<String>) = apply {
                        this.firstDimensionValue = firstDimensionValue
                    }

                    /** Scaling factor */
                    fun scalingFactor(scalingFactor: String) =
                        scalingFactor(JsonField.of(scalingFactor))

                    /**
                     * Sets [Builder.scalingFactor] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.scalingFactor] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun scalingFactor(scalingFactor: JsonField<String>) = apply {
                        this.scalingFactor = scalingFactor
                    }

                    /** Second dimension value (optional) */
                    fun secondDimensionValue(secondDimensionValue: String?) =
                        secondDimensionValue(JsonField.ofNullable(secondDimensionValue))

                    /**
                     * Sets [Builder.secondDimensionValue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.secondDimensionValue] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun secondDimensionValue(secondDimensionValue: JsonField<String>) = apply {
                        this.secondDimensionValue = secondDimensionValue
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [MatrixScalingFactor].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .firstDimensionValue()
                     * .scalingFactor()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): MatrixScalingFactor =
                        MatrixScalingFactor(
                            checkRequired("firstDimensionValue", firstDimensionValue),
                            checkRequired("scalingFactor", scalingFactor),
                            secondDimensionValue,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): MatrixScalingFactor = apply {
                    if (validated) {
                        return@apply
                    }

                    firstDimensionValue()
                    scalingFactor()
                    secondDimensionValue()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (firstDimensionValue.asKnown() == null) 0 else 1) +
                        (if (scalingFactor.asKnown() == null) 0 else 1) +
                        (if (secondDimensionValue.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MatrixScalingFactor &&
                        firstDimensionValue == other.firstDimensionValue &&
                        scalingFactor == other.scalingFactor &&
                        secondDimensionValue == other.secondDimensionValue &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        firstDimensionValue,
                        scalingFactor,
                        secondDimensionValue,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixScalingFactor{firstDimensionValue=$firstDimensionValue, scalingFactor=$scalingFactor, secondDimensionValue=$secondDimensionValue, additionalProperties=$additionalProperties}"
            }

            /** Configuration for a single tier entry with business logic */
            class Tier
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Per unit amount
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(tier: Tier) = apply {
                        tierLowerBound = tier.tierLowerBound
                        unitAmount = tier.unitAmount
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Per unit amount */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Tier].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Tier =
                        Tier(
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Tier &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is ScalableMatrixWithTieredPricingConfig &&
                    firstDimension == other.firstDimension &&
                    matrixScalingFactors == other.matrixScalingFactors &&
                    tiers == other.tiers &&
                    secondDimension == other.secondDimension &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    firstDimension,
                    matrixScalingFactors,
                    tiers,
                    secondDimension,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithTieredPricingConfig{firstDimension=$firstDimension, matrixScalingFactors=$matrixScalingFactors, tiers=$tiers, secondDimension=$secondDimension, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is ScalableMatrixWithTieredPricing &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                scalableMatrixWithTieredPricingConfig ==
                    other.scalableMatrixWithTieredPricingConfig &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                scalableMatrixWithTieredPricingConfig,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithTieredPricing{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class CumulativeGroupedBulk
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("cumulative_grouped_bulk_config")
            @ExcludeMissing
            cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            cumulativeGroupedBulkConfig,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * Configuration for cumulative_grouped_bulk pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cumulativeGroupedBulkConfig(): CumulativeGroupedBulkConfig =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("cumulative_grouped_bulk")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [cumulativeGroupedBulkConfig].
         *
         * Unlike [cumulativeGroupedBulkConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CumulativeGroupedBulkConfig> =
            cumulativeGroupedBulkConfig

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [CumulativeGroupedBulk].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [CumulativeGroupedBulk]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("cumulative_grouped_bulk")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(cumulativeGroupedBulk: CumulativeGroupedBulk) = apply {
                id = cumulativeGroupedBulk.id
                billableMetric = cumulativeGroupedBulk.billableMetric
                billingCycleConfiguration = cumulativeGroupedBulk.billingCycleConfiguration
                billingMode = cumulativeGroupedBulk.billingMode
                cadence = cumulativeGroupedBulk.cadence
                compositePriceFilters =
                    cumulativeGroupedBulk.compositePriceFilters.map { it.toMutableList() }
                conversionRate = cumulativeGroupedBulk.conversionRate
                conversionRateConfig = cumulativeGroupedBulk.conversionRateConfig
                createdAt = cumulativeGroupedBulk.createdAt
                creditAllocation = cumulativeGroupedBulk.creditAllocation
                cumulativeGroupedBulkConfig = cumulativeGroupedBulk.cumulativeGroupedBulkConfig
                currency = cumulativeGroupedBulk.currency
                discount = cumulativeGroupedBulk.discount
                externalPriceId = cumulativeGroupedBulk.externalPriceId
                fixedPriceQuantity = cumulativeGroupedBulk.fixedPriceQuantity
                invoicingCycleConfiguration = cumulativeGroupedBulk.invoicingCycleConfiguration
                item = cumulativeGroupedBulk.item
                maximum = cumulativeGroupedBulk.maximum
                maximumAmount = cumulativeGroupedBulk.maximumAmount
                metadata = cumulativeGroupedBulk.metadata
                minimum = cumulativeGroupedBulk.minimum
                minimumAmount = cumulativeGroupedBulk.minimumAmount
                modelType = cumulativeGroupedBulk.modelType
                name = cumulativeGroupedBulk.name
                planPhaseOrder = cumulativeGroupedBulk.planPhaseOrder
                priceType = cumulativeGroupedBulk.priceType
                replacesPriceId = cumulativeGroupedBulk.replacesPriceId
                dimensionalPriceConfiguration = cumulativeGroupedBulk.dimensionalPriceConfiguration
                additionalProperties = cumulativeGroupedBulk.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            /** Configuration for cumulative_grouped_bulk pricing */
            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            /**
             * Sets [Builder.cumulativeGroupedBulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cumulativeGroupedBulkConfig] with a well-typed
             * [CumulativeGroupedBulkConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("cumulative_grouped_bulk")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [CumulativeGroupedBulk].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): CumulativeGroupedBulk =
                CumulativeGroupedBulk(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): CumulativeGroupedBulk = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            cumulativeGroupedBulkConfig().validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("cumulative_grouped_bulk")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (cumulativeGroupedBulkConfig.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("cumulative_grouped_bulk")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for cumulative_grouped_bulk pricing */
        class CumulativeGroupedBulkConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val dimensionValues: JsonField<List<DimensionValue>>,
            private val group: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("dimension_values")
                @ExcludeMissing
                dimensionValues: JsonField<List<DimensionValue>> = JsonMissing.of(),
                @JsonProperty("group") @ExcludeMissing group: JsonField<String> = JsonMissing.of(),
            ) : this(dimensionValues, group, mutableMapOf())

            /**
             * Each tier lower bound must have the same group of values.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<DimensionValue> =
                dimensionValues.getRequired("dimension_values")

            /**
             * Grouping key name
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun group(): String = group.getRequired("group")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<DimensionValue>> = dimensionValues

            /**
             * Returns the raw JSON value of [group].
             *
             * Unlike [group], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("group") @ExcludeMissing fun _group(): JsonField<String> = group

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CumulativeGroupedBulkConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .dimensionValues()
                 * .group()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CumulativeGroupedBulkConfig]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<DimensionValue>>? = null
                private var group: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig) =
                    apply {
                        dimensionValues =
                            cumulativeGroupedBulkConfig.dimensionValues.map { it.toMutableList() }
                        group = cumulativeGroupedBulkConfig.group
                        additionalProperties =
                            cumulativeGroupedBulkConfig.additionalProperties.toMutableMap()
                    }

                /** Each tier lower bound must have the same group of values. */
                fun dimensionValues(dimensionValues: List<DimensionValue>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<DimensionValue>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<DimensionValue>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [DimensionValue] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: DimensionValue) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                /** Grouping key name */
                fun group(group: String) = group(JsonField.of(group))

                /**
                 * Sets [Builder.group] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.group] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun group(group: JsonField<String>) = apply { this.group = group }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CumulativeGroupedBulkConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .dimensionValues()
                 * .group()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CumulativeGroupedBulkConfig =
                    CumulativeGroupedBulkConfig(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("group", group),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CumulativeGroupedBulkConfig = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues().forEach { it.validate() }
                group()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (dimensionValues.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (group.asKnown() == null) 0 else 1)

            /** Configuration for a dimension value entry */
            class DimensionValue
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val groupingKey: JsonField<String>,
                private val tierLowerBound: JsonField<String>,
                private val unitAmount: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("grouping_key")
                    @ExcludeMissing
                    groupingKey: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("tier_lower_bound")
                    @ExcludeMissing
                    tierLowerBound: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("unit_amount")
                    @ExcludeMissing
                    unitAmount: JsonField<String> = JsonMissing.of(),
                ) : this(groupingKey, tierLowerBound, unitAmount, mutableMapOf())

                /**
                 * Grouping key value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun groupingKey(): String = groupingKey.getRequired("grouping_key")

                /**
                 * Tier lower bound
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun tierLowerBound(): String = tierLowerBound.getRequired("tier_lower_bound")

                /**
                 * Unit amount for this combination
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [groupingKey].
                 *
                 * Unlike [groupingKey], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("grouping_key")
                @ExcludeMissing
                fun _groupingKey(): JsonField<String> = groupingKey

                /**
                 * Returns the raw JSON value of [tierLowerBound].
                 *
                 * Unlike [tierLowerBound], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("tier_lower_bound")
                @ExcludeMissing
                fun _tierLowerBound(): JsonField<String> = tierLowerBound

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [DimensionValue].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .groupingKey()
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [DimensionValue]. */
                class Builder internal constructor() {

                    private var groupingKey: JsonField<String>? = null
                    private var tierLowerBound: JsonField<String>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(dimensionValue: DimensionValue) = apply {
                        groupingKey = dimensionValue.groupingKey
                        tierLowerBound = dimensionValue.tierLowerBound
                        unitAmount = dimensionValue.unitAmount
                        additionalProperties = dimensionValue.additionalProperties.toMutableMap()
                    }

                    /** Grouping key value */
                    fun groupingKey(groupingKey: String) = groupingKey(JsonField.of(groupingKey))

                    /**
                     * Sets [Builder.groupingKey] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.groupingKey] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun groupingKey(groupingKey: JsonField<String>) = apply {
                        this.groupingKey = groupingKey
                    }

                    /** Tier lower bound */
                    fun tierLowerBound(tierLowerBound: String) =
                        tierLowerBound(JsonField.of(tierLowerBound))

                    /**
                     * Sets [Builder.tierLowerBound] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.tierLowerBound] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun tierLowerBound(tierLowerBound: JsonField<String>) = apply {
                        this.tierLowerBound = tierLowerBound
                    }

                    /** Unit amount for this combination */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [DimensionValue].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .groupingKey()
                     * .tierLowerBound()
                     * .unitAmount()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): DimensionValue =
                        DimensionValue(
                            checkRequired("groupingKey", groupingKey),
                            checkRequired("tierLowerBound", tierLowerBound),
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): DimensionValue = apply {
                    if (validated) {
                        return@apply
                    }

                    groupingKey()
                    tierLowerBound()
                    unitAmount()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: OrbInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (groupingKey.asKnown() == null) 0 else 1) +
                        (if (tierLowerBound.asKnown() == null) 0 else 1) +
                        (if (unitAmount.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is DimensionValue &&
                        groupingKey == other.groupingKey &&
                        tierLowerBound == other.tierLowerBound &&
                        unitAmount == other.unitAmount &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(groupingKey, tierLowerBound, unitAmount, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "DimensionValue{groupingKey=$groupingKey, tierLowerBound=$tierLowerBound, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CumulativeGroupedBulkConfig &&
                    dimensionValues == other.dimensionValues &&
                    group == other.group &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(dimensionValues, group, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CumulativeGroupedBulkConfig{dimensionValues=$dimensionValues, group=$group, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is CumulativeGroupedBulk &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                cumulativeGroupedBulkConfig,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "CumulativeGroupedBulk{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Minimum
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val minimumConfig: JsonField<MinimumConfig>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("minimum_config")
            @ExcludeMissing
            minimumConfig: JsonField<MinimumConfig> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            minimumConfig,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * Configuration for minimum pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun minimumConfig(): MinimumConfig = minimumConfig.getRequired("minimum_config")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [minimumConfig].
         *
         * Unlike [minimumConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_config")
        @ExcludeMissing
        fun _minimumConfig(): JsonField<MinimumConfig> = minimumConfig

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Minimum].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .minimumConfig()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Minimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var minimumConfig: JsonField<MinimumConfig>? = null
            private var modelType: JsonValue = JsonValue.from("minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(minimum: Minimum) = apply {
                id = minimum.id
                billableMetric = minimum.billableMetric
                billingCycleConfiguration = minimum.billingCycleConfiguration
                billingMode = minimum.billingMode
                cadence = minimum.cadence
                compositePriceFilters = minimum.compositePriceFilters.map { it.toMutableList() }
                conversionRate = minimum.conversionRate
                conversionRateConfig = minimum.conversionRateConfig
                createdAt = minimum.createdAt
                creditAllocation = minimum.creditAllocation
                currency = minimum.currency
                discount = minimum.discount
                externalPriceId = minimum.externalPriceId
                fixedPriceQuantity = minimum.fixedPriceQuantity
                invoicingCycleConfiguration = minimum.invoicingCycleConfiguration
                item = minimum.item
                maximum = minimum.maximum
                maximumAmount = minimum.maximumAmount
                metadata = minimum.metadata
                this.minimum = minimum.minimum
                minimumAmount = minimum.minimumAmount
                minimumConfig = minimum.minimumConfig
                modelType = minimum.modelType
                name = minimum.name
                planPhaseOrder = minimum.planPhaseOrder
                priceType = minimum.priceType
                replacesPriceId = minimum.replacesPriceId
                dimensionalPriceConfiguration = minimum.dimensionalPriceConfiguration
                additionalProperties = minimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /** Configuration for minimum pricing */
            fun minimumConfig(minimumConfig: MinimumConfig) =
                minimumConfig(JsonField.of(minimumConfig))

            /**
             * Sets [Builder.minimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumConfig] with a well-typed [MinimumConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun minimumConfig(minimumConfig: JsonField<MinimumConfig>) = apply {
                this.minimumConfig = minimumConfig
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Minimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .minimumConfig()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Minimum =
                Minimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("minimumConfig", minimumConfig),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Minimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            minimumConfig().validate()
            _modelType().let {
                if (it != JsonValue.from("minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                (minimumConfig.asKnown()?.validity() ?: 0) +
                modelType.let { if (it == JsonValue.from("minimum")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        /** Configuration for minimum pricing */
        class MinimumConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val minimumAmount: JsonField<String>,
            private val prorated: JsonField<Boolean>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                minimumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("prorated")
                @ExcludeMissing
                prorated: JsonField<Boolean> = JsonMissing.of(),
            ) : this(minimumAmount, prorated, mutableMapOf())

            /**
             * The minimum amount to apply
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * If true, subtotals from this price are prorated based on the service period
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun prorated(): Boolean? = prorated.getNullable("prorated")

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            /**
             * Returns the raw JSON value of [prorated].
             *
             * Unlike [prorated], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("prorated") @ExcludeMissing fun _prorated(): JsonField<Boolean> = prorated

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [MinimumConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .minimumAmount()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [MinimumConfig]. */
            class Builder internal constructor() {

                private var minimumAmount: JsonField<String>? = null
                private var prorated: JsonField<Boolean> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(minimumConfig: MinimumConfig) = apply {
                    minimumAmount = minimumConfig.minimumAmount
                    prorated = minimumConfig.prorated
                    additionalProperties = minimumConfig.additionalProperties.toMutableMap()
                }

                /** The minimum amount to apply */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                /** If true, subtotals from this price are prorated based on the service period */
                fun prorated(prorated: Boolean) = prorated(JsonField.of(prorated))

                /**
                 * Sets [Builder.prorated] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.prorated] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun prorated(prorated: JsonField<Boolean>) = apply { this.prorated = prorated }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .minimumAmount()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): MinimumConfig =
                    MinimumConfig(
                        checkRequired("minimumAmount", minimumAmount),
                        prorated,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): MinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                minimumAmount()
                prorated()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                    (if (prorated.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is MinimumConfig &&
                    minimumAmount == other.minimumAmount &&
                    prorated == other.prorated &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(minimumAmount, prorated, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MinimumConfig{minimumAmount=$minimumAmount, prorated=$prorated, additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Minimum &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                minimumConfig == other.minimumConfig &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                minimumConfig,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Minimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, minimumConfig=$minimumConfig, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Percent
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val percentConfig: JsonField<PercentConfig>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("percent_config")
            @ExcludeMissing
            percentConfig: JsonField<PercentConfig> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            percentConfig,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("percent")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * Configuration for percent pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun percentConfig(): PercentConfig = percentConfig.getRequired("percent_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [percentConfig].
         *
         * Unlike [percentConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("percent_config")
        @ExcludeMissing
        fun _percentConfig(): JsonField<PercentConfig> = percentConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Percent].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .percentConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Percent]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("percent")
            private var name: JsonField<String>? = null
            private var percentConfig: JsonField<PercentConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(percent: Percent) = apply {
                id = percent.id
                billableMetric = percent.billableMetric
                billingCycleConfiguration = percent.billingCycleConfiguration
                billingMode = percent.billingMode
                cadence = percent.cadence
                compositePriceFilters = percent.compositePriceFilters.map { it.toMutableList() }
                conversionRate = percent.conversionRate
                conversionRateConfig = percent.conversionRateConfig
                createdAt = percent.createdAt
                creditAllocation = percent.creditAllocation
                currency = percent.currency
                discount = percent.discount
                externalPriceId = percent.externalPriceId
                fixedPriceQuantity = percent.fixedPriceQuantity
                invoicingCycleConfiguration = percent.invoicingCycleConfiguration
                item = percent.item
                maximum = percent.maximum
                maximumAmount = percent.maximumAmount
                metadata = percent.metadata
                minimum = percent.minimum
                minimumAmount = percent.minimumAmount
                modelType = percent.modelType
                name = percent.name
                percentConfig = percent.percentConfig
                planPhaseOrder = percent.planPhaseOrder
                priceType = percent.priceType
                replacesPriceId = percent.replacesPriceId
                dimensionalPriceConfiguration = percent.dimensionalPriceConfiguration
                additionalProperties = percent.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("percent")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            /** Configuration for percent pricing */
            fun percentConfig(percentConfig: PercentConfig) =
                percentConfig(JsonField.of(percentConfig))

            /**
             * Sets [Builder.percentConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.percentConfig] with a well-typed [PercentConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun percentConfig(percentConfig: JsonField<PercentConfig>) = apply {
                this.percentConfig = percentConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Percent].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .percentConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Percent =
                Percent(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("percentConfig", percentConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Percent = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("percent")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            percentConfig().validate()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("percent")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (percentConfig.asKnown()?.validity() ?: 0) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        /** Configuration for percent pricing */
        class PercentConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val percent: JsonField<Double>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("percent")
                @ExcludeMissing
                percent: JsonField<Double> = JsonMissing.of()
            ) : this(percent, mutableMapOf())

            /**
             * What percent of the component subtotals to charge
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun percent(): Double = percent.getRequired("percent")

            /**
             * Returns the raw JSON value of [percent].
             *
             * Unlike [percent], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("percent") @ExcludeMissing fun _percent(): JsonField<Double> = percent

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [PercentConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .percent()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [PercentConfig]. */
            class Builder internal constructor() {

                private var percent: JsonField<Double>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(percentConfig: PercentConfig) = apply {
                    percent = percentConfig.percent
                    additionalProperties = percentConfig.additionalProperties.toMutableMap()
                }

                /** What percent of the component subtotals to charge */
                fun percent(percent: Double) = percent(JsonField.of(percent))

                /**
                 * Sets [Builder.percent] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.percent] with a well-typed [Double] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun percent(percent: JsonField<Double>) = apply { this.percent = percent }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [PercentConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .percent()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): PercentConfig =
                    PercentConfig(
                        checkRequired("percent", percent),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): PercentConfig = apply {
                if (validated) {
                    return@apply
                }

                percent()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (percent.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PercentConfig &&
                    percent == other.percent &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(percent, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PercentConfig{percent=$percent, additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Percent &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                percentConfig == other.percentConfig &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                percentConfig,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Percent{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, percentConfig=$percentConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class EventOutput
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val billingMode: JsonField<BillingMode>,
        private val cadence: JsonField<Cadence>,
        private val compositePriceFilters: JsonField<List<TransformPriceFilter>>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val eventOutputConfig: JsonField<EventOutputConfig>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("billing_mode")
            @ExcludeMissing
            billingMode: JsonField<BillingMode> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("composite_price_filters")
            @ExcludeMissing
            compositePriceFilters: JsonField<List<TransformPriceFilter>> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("event_output_config")
            @ExcludeMissing
            eventOutputConfig: JsonField<EventOutputConfig> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            billingMode,
            cadence,
            compositePriceFilters,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            eventOutputConfig,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): BillableMetricTiny? = billableMetric.getNullable("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingMode(): BillingMode = billingMode.getRequired("billing_mode")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun compositePriceFilters(): List<TransformPriceFilter>? =
            compositePriceFilters.getNullable("composite_price_filters")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Double? = conversionRate.getNullable("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): ConversionRateConfig? =
            conversionRateConfig.getNullable("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Allocation? = creditAllocation.getNullable("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun discount(): Discount? = discount.getNullable("discount")

        /**
         * Configuration for event_output pricing
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun eventOutputConfig(): EventOutputConfig =
            eventOutputConfig.getRequired("event_output_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): String? = externalPriceId.getNullable("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Double? = fixedPriceQuantity.getNullable("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): BillingCycleConfiguration? =
            invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")

        /**
         * A minimal representation of an Item containing only the essential identifying
         * information.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Maximum? = maximum.getNullable("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): String? = maximumAmount.getNullable("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Minimum? = minimum.getNullable("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): String? = minimumAmount.getNullable("minimum_amount")

        /**
         * The pricing model type
         *
         * Expected to always return the following:
         * ```kotlin
         * JsonValue.from("event_output")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Long? = planPhaseOrder.getNullable("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): String? = replacesPriceId.getNullable("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): DimensionalPriceConfiguration? =
            dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [billingMode].
         *
         * Unlike [billingMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("billing_mode")
        @ExcludeMissing
        fun _billingMode(): JsonField<BillingMode> = billingMode

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [compositePriceFilters].
         *
         * Unlike [compositePriceFilters], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("composite_price_filters")
        @ExcludeMissing
        fun _compositePriceFilters(): JsonField<List<TransformPriceFilter>> = compositePriceFilters

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [eventOutputConfig].
         *
         * Unlike [eventOutputConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("event_output_config")
        @ExcludeMissing
        fun _eventOutputConfig(): JsonField<EventOutputConfig> = eventOutputConfig

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [EventOutput].
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .eventOutputConfig()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [EventOutput]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var billingMode: JsonField<BillingMode>? = null
            private var cadence: JsonField<Cadence>? = null
            private var compositePriceFilters: JsonField<MutableList<TransformPriceFilter>>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var eventOutputConfig: JsonField<EventOutputConfig>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("event_output")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(eventOutput: EventOutput) = apply {
                id = eventOutput.id
                billableMetric = eventOutput.billableMetric
                billingCycleConfiguration = eventOutput.billingCycleConfiguration
                billingMode = eventOutput.billingMode
                cadence = eventOutput.cadence
                compositePriceFilters = eventOutput.compositePriceFilters.map { it.toMutableList() }
                conversionRate = eventOutput.conversionRate
                conversionRateConfig = eventOutput.conversionRateConfig
                createdAt = eventOutput.createdAt
                creditAllocation = eventOutput.creditAllocation
                currency = eventOutput.currency
                discount = eventOutput.discount
                eventOutputConfig = eventOutput.eventOutputConfig
                externalPriceId = eventOutput.externalPriceId
                fixedPriceQuantity = eventOutput.fixedPriceQuantity
                invoicingCycleConfiguration = eventOutput.invoicingCycleConfiguration
                item = eventOutput.item
                maximum = eventOutput.maximum
                maximumAmount = eventOutput.maximumAmount
                metadata = eventOutput.metadata
                minimum = eventOutput.minimum
                minimumAmount = eventOutput.minimumAmount
                modelType = eventOutput.modelType
                name = eventOutput.name
                planPhaseOrder = eventOutput.planPhaseOrder
                priceType = eventOutput.priceType
                replacesPriceId = eventOutput.replacesPriceId
                dimensionalPriceConfiguration = eventOutput.dimensionalPriceConfiguration
                additionalProperties = eventOutput.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun billingMode(billingMode: BillingMode) = billingMode(JsonField.of(billingMode))

            /**
             * Sets [Builder.billingMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingMode] with a well-typed [BillingMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun billingMode(billingMode: JsonField<BillingMode>) = apply {
                this.billingMode = billingMode
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun compositePriceFilters(compositePriceFilters: List<TransformPriceFilter>?) =
                compositePriceFilters(JsonField.ofNullable(compositePriceFilters))

            /**
             * Sets [Builder.compositePriceFilters] to an arbitrary JSON value.
             *
             * You should usually call [Builder.compositePriceFilters] with a well-typed
             * `List<TransformPriceFilter>` value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun compositePriceFilters(
                compositePriceFilters: JsonField<List<TransformPriceFilter>>
            ) = apply {
                this.compositePriceFilters = compositePriceFilters.map { it.toMutableList() }
            }

            /**
             * Adds a single [TransformPriceFilter] to [compositePriceFilters].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addCompositePriceFilter(compositePriceFilter: TransformPriceFilter) = apply {
                compositePriceFilters =
                    (compositePriceFilters ?: JsonField.of(mutableListOf())).also {
                        checkKnown("compositePriceFilters", it).add(compositePriceFilter)
                    }
            }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```kotlin
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```kotlin
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            /** Configuration for event_output pricing */
            fun eventOutputConfig(eventOutputConfig: EventOutputConfig) =
                eventOutputConfig(JsonField.of(eventOutputConfig))

            /**
             * Sets [Builder.eventOutputConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.eventOutputConfig] with a well-typed
             * [EventOutputConfig] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun eventOutputConfig(eventOutputConfig: JsonField<EventOutputConfig>) = apply {
                this.eventOutputConfig = eventOutputConfig
            }

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            /**
             * A minimal representation of an Item containing only the essential identifying
             * information.
             */
            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```kotlin
             * JsonValue.from("event_output")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [EventOutput].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .billingMode()
             * .cadence()
             * .compositePriceFilters()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .eventOutputConfig()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): EventOutput =
                EventOutput(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("billingMode", billingMode),
                    checkRequired("cadence", cadence),
                    checkRequired("compositePriceFilters", compositePriceFilters).map {
                        it.toImmutable()
                    },
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("eventOutputConfig", eventOutputConfig),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): EventOutput = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric()?.validate()
            billingCycleConfiguration().validate()
            billingMode().validate()
            cadence().validate()
            compositePriceFilters()?.forEach { it.validate() }
            conversionRate()
            conversionRateConfig()?.validate()
            createdAt()
            creditAllocation()?.validate()
            currency()
            discount()?.validate()
            eventOutputConfig().validate()
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration()?.validate()
            item().validate()
            maximum()?.validate()
            maximumAmount()
            metadata().validate()
            minimum()?.validate()
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("event_output")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (id.asKnown() == null) 0 else 1) +
                (billableMetric.asKnown()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (billingMode.asKnown()?.validity() ?: 0) +
                (cadence.asKnown()?.validity() ?: 0) +
                (compositePriceFilters.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (conversionRate.asKnown() == null) 0 else 1) +
                (conversionRateConfig.asKnown()?.validity() ?: 0) +
                (if (createdAt.asKnown() == null) 0 else 1) +
                (creditAllocation.asKnown()?.validity() ?: 0) +
                (if (currency.asKnown() == null) 0 else 1) +
                (discount.asKnown()?.validity() ?: 0) +
                (eventOutputConfig.asKnown()?.validity() ?: 0) +
                (if (externalPriceId.asKnown() == null) 0 else 1) +
                (if (fixedPriceQuantity.asKnown() == null) 0 else 1) +
                (invoicingCycleConfiguration.asKnown()?.validity() ?: 0) +
                (item.asKnown()?.validity() ?: 0) +
                (maximum.asKnown()?.validity() ?: 0) +
                (if (maximumAmount.asKnown() == null) 0 else 1) +
                (metadata.asKnown()?.validity() ?: 0) +
                (minimum.asKnown()?.validity() ?: 0) +
                (if (minimumAmount.asKnown() == null) 0 else 1) +
                modelType.let { if (it == JsonValue.from("event_output")) 1 else 0 } +
                (if (name.asKnown() == null) 0 else 1) +
                (if (planPhaseOrder.asKnown() == null) 0 else 1) +
                (priceType.asKnown()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown() == null) 0 else 1) +
                (dimensionalPriceConfiguration.asKnown()?.validity() ?: 0)

        class BillingMode @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val IN_ADVANCE = of("in_advance")

                val IN_ARREAR = of("in_arrear")

                fun of(value: String) = BillingMode(JsonField.of(value))
            }

            /** An enum containing [BillingMode]'s known values. */
            enum class Known {
                IN_ADVANCE,
                IN_ARREAR,
            }

            /**
             * An enum containing [BillingMode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [BillingMode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                IN_ADVANCE,
                IN_ARREAR,
                /**
                 * An enum member indicating that [BillingMode] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    IN_ADVANCE -> Value.IN_ADVANCE
                    IN_ARREAR -> Value.IN_ARREAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    IN_ADVANCE -> Known.IN_ADVANCE
                    IN_ARREAR -> Known.IN_ARREAR
                    else -> throw OrbInvalidDataException("Unknown BillingMode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): BillingMode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BillingMode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val ONE_TIME = of("one_time")

                val MONTHLY = of("monthly")

                val QUARTERLY = of("quarterly")

                val SEMI_ANNUAL = of("semi_annual")

                val ANNUAL = of("annual")

                val CUSTOM = of("custom")

                fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Cadence && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Configuration for event_output pricing */
        class EventOutputConfig
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val unitRatingKey: JsonField<String>,
            private val groupingKey: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("unit_rating_key")
                @ExcludeMissing
                unitRatingKey: JsonField<String> = JsonMissing.of(),
                @JsonProperty("grouping_key")
                @ExcludeMissing
                groupingKey: JsonField<String> = JsonMissing.of(),
            ) : this(unitRatingKey, groupingKey, mutableMapOf())

            /**
             * The key in the event data to extract the unit rate from.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitRatingKey(): String = unitRatingKey.getRequired("unit_rating_key")

            /**
             * An optional key in the event data to group by (e.g., event ID). All events will also
             * be grouped by their unit rate.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun groupingKey(): String? = groupingKey.getNullable("grouping_key")

            /**
             * Returns the raw JSON value of [unitRatingKey].
             *
             * Unlike [unitRatingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_rating_key")
            @ExcludeMissing
            fun _unitRatingKey(): JsonField<String> = unitRatingKey

            /**
             * Returns the raw JSON value of [groupingKey].
             *
             * Unlike [groupingKey], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("grouping_key")
            @ExcludeMissing
            fun _groupingKey(): JsonField<String> = groupingKey

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [EventOutputConfig].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .unitRatingKey()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [EventOutputConfig]. */
            class Builder internal constructor() {

                private var unitRatingKey: JsonField<String>? = null
                private var groupingKey: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(eventOutputConfig: EventOutputConfig) = apply {
                    unitRatingKey = eventOutputConfig.unitRatingKey
                    groupingKey = eventOutputConfig.groupingKey
                    additionalProperties = eventOutputConfig.additionalProperties.toMutableMap()
                }

                /** The key in the event data to extract the unit rate from. */
                fun unitRatingKey(unitRatingKey: String) =
                    unitRatingKey(JsonField.of(unitRatingKey))

                /**
                 * Sets [Builder.unitRatingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitRatingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitRatingKey(unitRatingKey: JsonField<String>) = apply {
                    this.unitRatingKey = unitRatingKey
                }

                /**
                 * An optional key in the event data to group by (e.g., event ID). All events will
                 * also be grouped by their unit rate.
                 */
                fun groupingKey(groupingKey: String?) =
                    groupingKey(JsonField.ofNullable(groupingKey))

                /**
                 * Sets [Builder.groupingKey] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.groupingKey] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun groupingKey(groupingKey: JsonField<String>) = apply {
                    this.groupingKey = groupingKey
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [EventOutputConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .unitRatingKey()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): EventOutputConfig =
                    EventOutputConfig(
                        checkRequired("unitRatingKey", unitRatingKey),
                        groupingKey,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): EventOutputConfig = apply {
                if (validated) {
                    return@apply
                }

                unitRatingKey()
                groupingKey()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (unitRatingKey.asKnown() == null) 0 else 1) +
                    (if (groupingKey.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is EventOutputConfig &&
                    unitRatingKey == other.unitRatingKey &&
                    groupingKey == other.groupingKey &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(unitRatingKey, groupingKey, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "EventOutputConfig{unitRatingKey=$unitRatingKey, groupingKey=$groupingKey, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Metadata && additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                val USAGE_PRICE = of("usage_price")

                val FIXED_PRICE = of("fixed_price")

                val COMPOSITE_PRICE = of("composite_price")

                fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                COMPOSITE_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    COMPOSITE_PRICE -> Value.COMPOSITE_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    COMPOSITE_PRICE -> Known.COMPOSITE_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw OrbInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is PriceType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is EventOutput &&
                id == other.id &&
                billableMetric == other.billableMetric &&
                billingCycleConfiguration == other.billingCycleConfiguration &&
                billingMode == other.billingMode &&
                cadence == other.cadence &&
                compositePriceFilters == other.compositePriceFilters &&
                conversionRate == other.conversionRate &&
                conversionRateConfig == other.conversionRateConfig &&
                createdAt == other.createdAt &&
                creditAllocation == other.creditAllocation &&
                currency == other.currency &&
                discount == other.discount &&
                eventOutputConfig == other.eventOutputConfig &&
                externalPriceId == other.externalPriceId &&
                fixedPriceQuantity == other.fixedPriceQuantity &&
                invoicingCycleConfiguration == other.invoicingCycleConfiguration &&
                item == other.item &&
                maximum == other.maximum &&
                maximumAmount == other.maximumAmount &&
                metadata == other.metadata &&
                minimum == other.minimum &&
                minimumAmount == other.minimumAmount &&
                modelType == other.modelType &&
                name == other.name &&
                planPhaseOrder == other.planPhaseOrder &&
                priceType == other.priceType &&
                replacesPriceId == other.replacesPriceId &&
                dimensionalPriceConfiguration == other.dimensionalPriceConfiguration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                id,
                billableMetric,
                billingCycleConfiguration,
                billingMode,
                cadence,
                compositePriceFilters,
                conversionRate,
                conversionRateConfig,
                createdAt,
                creditAllocation,
                currency,
                discount,
                eventOutputConfig,
                externalPriceId,
                fixedPriceQuantity,
                invoicingCycleConfiguration,
                item,
                maximum,
                maximumAmount,
                metadata,
                minimum,
                minimumAmount,
                modelType,
                name,
                planPhaseOrder,
                priceType,
                replacesPriceId,
                dimensionalPriceConfiguration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "EventOutput{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, billingMode=$billingMode, cadence=$cadence, compositePriceFilters=$compositePriceFilters, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, eventOutputConfig=$eventOutputConfig, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }
}
